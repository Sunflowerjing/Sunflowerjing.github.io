(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{221:function(a,v,e){"use strict";e.r(v);var _=e(0),t=Object(_.a)({},(function(){var a=this,v=a.$createElement,e=a._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"javascript函数编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript函数编程"}},[a._v("#")]),a._v(" JavaScript函数编程")]),a._v(" "),e("h2",{attrs:{id:"函数编程的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数编程的理解"}},[a._v("#")]),a._v(" 函数编程的理解")]),a._v(" "),e("p",[e("img",{attrs:{src:"%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B.png",alt:"JavaScript函数编程"}})]),a._v(" "),e("ol",[e("li",[e("code",[a._v("所有成员")]),a._v("是一个"),e("code",[a._v("集合")])]),a._v(" "),e("li",[e("code",[a._v("变形关系")]),a._v("是"),e("code",[a._v("函数")])])]),a._v(" "),e("h2",{attrs:{id:"函数式编程基础理论"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程基础理论"}},[a._v("#")]),a._v(" 函数式编程基础理论")]),a._v(" "),e("ol",[e("li",[e("code",[a._v("数学中的函数书写")]),a._v(": 如下形式"),e("code",[a._v("f(X)=Y")]),a._v("。一个"),e("code",[a._v("函数F")]),a._v(",已"),e("code",[a._v("X为参数")]),a._v("， 并返回"),e("code",[a._v("输出Y")]),a._v("。这很简单，但是包含几个关键点:\n"),e("ul",[e("li",[a._v("函数必须总是"),e("code",[a._v("接受一个参数")]),a._v(" (若有多元的，则转换成一元的)")]),a._v(" "),e("li",[a._v("函数必须"),e("code",[a._v("返回一个值")])]),a._v(" "),e("li",[a._v("函数应该依据接"),e("code",[a._v("收到的参数")]),a._v("(如X)"),e("code",[a._v("而不是外部环境")]),a._v("运行")]),a._v(" "),e("li",[a._v("对于"),e("code",[a._v("给定的X只会输出唯一的Y")]),a._v("。")])])]),a._v(" "),e("li",[a._v("函数式编程不是用函数来编程，也不是传统的面向过程编程。主旨在于"),e("code",[a._v("将复杂的函数符合成简单的函数")]),a._v("(计算理论，或者递归论， 或者拉姆达演算)。"),e("code",[a._v("运算过程尽量写成一系列嵌套的函数调用")]),a._v("(lambda 函数)")]),a._v(" "),e("li",[a._v("通俗"),e("code",[a._v("函数")]),a._v("写法 "),e("code",[a._v("function xx(){}")]),a._v(", 要区别开"),e("code",[a._v("函数")]),a._v("和"),e("code",[a._v("方法")]),a._v("。\n"),e("ul",[e("li",[a._v("方法要与指定的对象绑定"),e("code",[a._v("( obj={ test(){} } )")]),a._v("、函数可以直接调用。")]),a._v(" "),e("li",[a._v("函数就是没有 this。"),e("code",[a._v("不属于某个对象, 直接调用")]),a._v("。")]),a._v(" "),e("li",[a._v("方法属于某个对象或者类。")])])]),a._v(" "),e("li",[a._v("HOC: 高阶函数")])]),a._v(" "),e("h2",{attrs:{id:"函数式编程思想深入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程思想深入"}},[a._v("#")]),a._v(" 函数式编程思想深入")]),a._v(" "),e("ol",[e("li",[e("code",[a._v("函数是一等公民(表示到处可以用)")]),a._v("。所谓”第一等公民”("),e("code",[a._v("first class")]),a._v(")，指的是函数与其他数据类型一样，处于平等地位。可以"),e("code",[a._v("赋值给其他变量")]),a._v("，也"),e("code",[a._v("可以作为参数")]),a._v("，传入另一个函数，或者"),e("code",[a._v("作为别的函数的返回值")]),a._v("。")]),a._v(" "),e("li",[e("code",[a._v("不可改变量")]),a._v("。在函数式编程中，我们通常理解的变量在函数式编程中也被函数代替了: 在函数式编程中"),e("code",[a._v("变量仅仅代表某个表达式")]),a._v("。这里所说的’变量’是不能被修改的。"),e("code",[a._v("所有的变量只能被赋一次初值")])]),a._v(" "),e("li",[a._v("map & reduce 他们是最常用的函数式编程的方法。")]),a._v(" "),e("li",[a._v("总结:\n"),e("ul",[e("li",[a._v("函数是”第一等公民”")]),a._v(" "),e("li",[a._v('只用”表达式"，不用"语句"。例如: if else、try catch都不存在')]),a._v(" "),e("li",[a._v('没有”副作用"')]),a._v(" "),e("li",[a._v("不修改状态")]),a._v(" "),e("li",[a._v("引用透明("),e("code",[a._v("函数运行只靠参数且相同的输入总是获得相同的输出")]),a._v(")\nidentity=(i)=>{return i} 调用identity(1)可以直接替换为1 该过程被称为"),e("code",[a._v("替换模型")])])])])]),a._v(" "),e("h2",{attrs:{id:"函数式编程常用核心概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程常用核心概念"}},[a._v("#")]),a._v(" 函数式编程常用核心概念")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("纯函数")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("对于相同的输入，永远会得到相同的输出")]),a._v("，而且没有任何可观察的副作用，"),e("code",[a._v("也不依赖外部环境的状态")]),a._v("。")]),a._v(" "),e("li",[e("code",[a._v("Array.slice")]),a._v("是纯函数，因为它没有副作用，"),e("code",[a._v("对于固定的输入，输出总是固定的")]),a._v("。")]),a._v(" "),e("li",[e("code",[a._v("splice")]),a._v(" 就不是纯函数，会改变原数组")]),a._v(" "),e("li",[a._v("优点: 纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，比如可缓存性")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("import _ from 'lodash';\nvar sin = _.memorize(x => Math.sin(x));\n//第一次计算的时候会稍慢一点 \nvar a = sin(1);\n//第二次有了缓存，速度极快\nvar b = sin(1); \n")])])]),e("ul",[e("li",[a._v("缺点")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("//不纯的\nvar min = 18;\nvar checkage = age => age > min;\n//纯的，这很函数式\nvar checkage = age => age > 18;\n\n在不纯的版本中，checkage 不仅取决于 age 还有外部依赖的变量 min。\n纯的 checkage 把关键数字 18 硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。\n")])])]),e("ul",[e("li",[a._v("纯度和幂等性\n"),e("ul",[e("li",[e("code",[a._v("幂等性")]),a._v("是指"),e("code",[a._v("执行无数次后")]),a._v("还具"),e("code",[a._v("有相同的效果")]),a._v("，"),e("code",[a._v("同一的参数``运行一次函数")]),a._v("应该与"),e("code",[a._v("连续两次")]),a._v("结果一致。")]),a._v(" "),e("li",[e("code",[a._v("幂等性在函数式编程中与纯度相关，但有不一致。")])]),a._v(" "),e("li",[e("code",[a._v("纯函数")]),a._v(": 表示输入和输入一致。"),e("code",[a._v("单独执行")])]),a._v(" "),e("li",[e("code",[a._v("幂等性")]),a._v(": 表示函数运行一次和运行多次是一样的。例如: "),e("code",[a._v("Math.abs(Math.abs(-42))")]),a._v("。"),e("code",[a._v("套起来执行")])])])])])]),a._v(" "),e("li",[e("p",[a._v("偏应用函数、函数的柯里化")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("柯里化")]),a._v("隶属于"),e("code",[a._v("偏应用函数")]),a._v(", 柯里化的解决方式是偏应用函数的一个"),e("code",[a._v("子集")]),a._v("。")]),a._v(" "),e("li",[e("code",[a._v("偏应用函数(partial application)")]),a._v(": 传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n"),e("ul",[e("li",[a._v("偏函数之所以“偏”，在就在于其只能处理那些能与"),e("code",[a._v("至少一个case语句匹配的输入")]),a._v("，"),e("code",[a._v("而不能处理所有可能的输入")]),a._v("。")]),a._v(" "),e("li",[a._v("偏应用函数案例: 接收 => 返回(接收) => 返回")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 带一个函数参数 和 该函数的部分参数 \nconst partial = (f, ...args) =>\n                (...moreArgs) => f(...args, ...moreArgs)\nconst add3 = (a, b, c) => a + b + c\n\n// 偏应用 `2` 和 `3` 到 `add3` 给你一个单参数的函数 \nconst fivePlus = partial(add3, 2, 3)\nfivePlus(4)\n\n//bind 实现\nconst add1More = add3.bind(null, 2, 3) // (c) => 2 + 3 + c\n")])])])]),a._v(" "),e("li",[e("code",[a._v("函数的柯里化")]),a._v(" "),e("ul",[e("li",[a._v("柯里化 (Curried) 通过偏应用函数实现。"),e("code",[a._v("它是把一个多参数函数转换为一个嵌套一元函数的过程。")])]),a._v(" "),e("li",[e("code",[a._v("传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数")]),a._v("。")]),a._v(" "),e("li",[a._v("我们一起来用柯里化来改他")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var checkage = min => (age => age > min); \nvar checkage18 = checkage(18); \ncheckage18(20);\n")])])]),e("ul",[e("li",[a._v("函数的柯里化code: "),e("code",[a._v("转换为一元函数")])])]),a._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 柯里化之前")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("add")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("x"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" y")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 这个就是多元函数")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" x "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" y"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("add")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 3")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 柯里化之后")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("addX")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("y")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("x")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" \n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" x "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" y"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("addX")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 3")]),a._v("\n")])])]),e("ul",[e("li",[a._v("函数柯里化优缺点")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('import { curry } from \'lodash\';\nvar match = curry((reg, str) => str.match(reg)); \nvar filter = curry((f, arr) => arr.filter(f));\nvar haveSpace = match(/\\s+/g); \n//haveSpace(“ffffffff”);\n//haveSpace(“a b");\n//filter(haveSpace, ["abcdefg", "Hello World"]); \nfilter(haveSpace)(["abcdefg", "Hello World"])  最优办法\n')])])]),e("ul",[e("li",[a._v("事实上柯里化是一种"),e("code",[a._v("“预加载”函数的方法")]),a._v("，通过传递较少的参数， 得到一个已经"),e("code",[a._v("记住了这些参数的新函数")]),a._v("，某种意义上讲，"),e("code",[a._v("这是一种对参数的“缓存”")]),a._v("，是一种非常高效的编写函数的方法。")])])]),a._v(" "),e("li",[a._v("柯里化和偏应用的区别: "),e("code",[a._v("柯里化的参数列表是从左向右的")]),a._v(", 偏应用函数不用关系顺序(含有占位符)。所以说柯里化是偏应用函数的一个子集。\n"),e("ul",[e("li",[a._v("例如 bind 严格意义讲, 是 偏应用 函数")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('function foo(p1, p2) {\n    this.val = p1 + p2; \n}\nvar bar = foo.bind(null, “p1”);  // null 是占位符\nvar baz = new bar("p2"); console.log(baz.val);  `\n')])])])]),a._v(" "),e("li",[e("code",[a._v("函数的反柯里化")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("函数柯里化")]),a._v(": 是固定部分参数，返回一个接受剩余参数的函数，也称为部分计算函数，目的是为了"),e("code",[a._v("缩小适用范围")]),a._v("，创建一个针对性更强的函数。")]),a._v(" "),e("li",[e("code",[a._v("反柯里化函数")]),a._v(": 意义和用法跟函数柯里化相比正好相反，"),e("code",[a._v("扩大适用范围")]),a._v("，创建一个应用范围更广的函数。使本来只有特定对象才适用的方法，扩展到更多的对象。")]),a._v(" "),e("li",[a._v("函数的反柯里化code")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('Function.prototype.uncurring = function() { \n    var self = this;\n    return function() {\n        var obj = Array.prototype.shift.call(arguments);\n        return self.apply(obj, arguments); };\n    };\nvar push = Array.prototype.push.unCurrying(),\nobj = {};\npush(obj, "first", "two"); \nconsole.log(obj);\n')])])])])])]),a._v(" "),e("li",[e("p",[a._v("函数组合")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("纯函数")]),a._v("以及如何把它"),e("code",[a._v("柯里化")]),a._v("写出的"),e("code",[a._v("洋葱代码 h(g(f(x)))")]),a._v("， 为了解决函数嵌套的问题，我们需要用到"),e("code",[a._v("“函数组合”")]),a._v(":")]),a._v(" "),e("li",[a._v("例子:")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const compose = (f, g) => (x => f(g(x)));\nvar first = arr => arr[0];\nvar reverse = arr => arr.reverse();\nvar last = compose(first, reverse);\nlast([1,2,3,4,5]);\n")])])]),e("ul",[e("li",[a._v("图解:\n"),e("img",{attrs:{src:"%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88.png",alt:"函数组合"}}),a._v(" "),e("ul",[e("li",[a._v("以下方式都称为函数组合")]),a._v(" "),e("li",[a._v("compose(f, compose(g, h))")]),a._v(" "),e("li",[a._v("compose(compose(f, g), h)")]),a._v(" "),e("li",[a._v("compose(f, g, h)")])])]),a._v(" "),e("li",[a._v("函数组合子\n"),e("ul",[e("li",[e("code",[a._v("compose函数")]),a._v("只能组合"),e("code",[a._v("接受一个参数的函数")]),a._v("，类似于"),e("code",[a._v("filter、map")]),a._v("接受两个参数("),e("code",[a._v("投影函数")]),a._v(": 总是在应用转换操作, 通过传入高阶参数后返回数组)，不能被直接组合可以借助偏函数包裹后继续组合。")]),a._v(" "),e("li",[e("code",[a._v("函数组合的数据流是从右至左")]),a._v("，因为"),e("code",[a._v("最右边的函数首先执行")]),a._v("， 将数据传递给下一个函数以此类推，有人喜欢另一种方式最左侧的先执行，我们可以实现"),e("code",[a._v("pipe")]),a._v("(可称为管道、序列)来实 现。它和compose所做的事情一样，只不过交换了数据方向。")]),a._v(" "),e("li",[a._v("因此我们需要组合子"),e("code",[a._v("管理程序的控制流")]),a._v("。")]),a._v(" "),e("li",[a._v("命令式代码能够使用 "),e("code",[a._v("if-else")]),a._v(" 和 "),e("code",[a._v("for")]),a._v(" 这样的过程控制，函数式则不能。\n"),e("ul",[e("li",[a._v("所以我们需要"),e("code",[a._v("函数组合子")]),a._v("。")]),a._v(" "),e("li",[a._v("组合子可以组合其他函数(或其他组合子)，并作为控制逻辑单元的"),e("code",[a._v("高阶函数")]),a._v("，组合子通常不声明任何变量，也不包含任何业务逻辑，他们旨在管理函数程序执行流程，并在链式调用中对中间结果进行操作。")])])]),a._v(" "),e("li",[a._v("常见的组合子如下\n"),e("ul",[e("li",[a._v("辅助组合子:\n"),e("ul",[e("li",[a._v("无为(nothing)、照旧(identity)、默许(defaultTo)、恒定(always)")])])]),a._v(" "),e("li",[a._v("函数组合子\n"),e("ul",[e("li",[a._v("收缩(gather)、展开(spread)、颠倒(reverse)、左偏(partial)、右偏 (partialRight)、"),e("code",[a._v("柯里化(curry)")]),a._v("、"),e("code",[a._v("弃离(tap)")]),a._v("、"),e("code",[a._v("交替(alt)")]),a._v("、补救(tryCatch)、同时 (seq)、聚集(converge)、映射(map)、分捡(useWith)、规约(reduce)、"),e("code",[a._v("组合(compose)")])])])]),a._v(" "),e("li",[a._v("谓语组合子\n"),e("ul",[e("li",[a._v("过滤(filter)、分组(group)、排序(sort)")])])]),a._v(" "),e("li",[a._v("其它: 组合子变换 juxt")]),a._v(" "),e("li",[a._v("分属于SKI组合子。")])])])])])])]),a._v(" "),e("li",[e("p",[a._v("Point Free")]),a._v(" "),e("ul",[e("li",[a._v("把一些对象自带的方法转化成纯函数, 不要命名转瞬即逝的中间变量。")]),a._v(" "),e("li",[a._v("这个函数中，我们使用了 str 作为我们的"),e("code",[a._v("中间变量")]),a._v("，但这个中间变量除了让代码变得长了一点以外是毫无意义的。")]),a._v(" "),e("li",[a._v("const f = str => str.toUpperCase().split(' ‘);  // 错误案例")]),a._v(" "),e("li",[a._v("正确案例")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var toUpperCase = word => word.toUpperCase(); \nvar split = x => (str => str.split(x));\n\nvar f = compose(split(' '), toUpperCase); \nf(\"abcd efgh\");\n\n// 这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。\n")])])])]),a._v(" "),e("li",[e("p",[a._v("声明式与命令式代码")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("命令式代码")]),a._v("的意思就是，我们通过"),e("code",[a._v("编写一条又一条指令")]),a._v("去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let CEOs = [];\nfor(var i = 0; i < companies.length; i++) {\n    CEOs.push(companies[i].CEO) \n}\n")])])]),e("ul",[e("li",[e("code",[a._v("声明式")]),a._v("就要优雅很多了，我们通过"),e("code",[a._v("写表达式的方式来声明")]),a._v("我们想干什么，而不是通过一步一步的指示。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let CEOs = companies.map(c => c.CEO);\n")])])]),e("ul",[e("li",[e("code",[a._v("函数式编程")]),a._v("的一个明显的好处就是这种"),e("code",[a._v("声明式的代码")]),a._v("，对于"),e("code",[a._v("无副作用的纯函数")]),a._v("，我们完全"),e("code",[a._v("可以不考虑函数内部是如何实现的")]),a._v("，专注于编写业务代码。优化代码时，目光只需要集中在这些稳定坚固的函数内部即可。")]),a._v(" "),e("li",[e("code",[a._v("不纯的函数式")]),a._v("代码会产生副作用或者依赖外部系统环境，使用它们的时候总是要考虑这些不干净的副作用。在复杂的系统中，这对于程序员的心智来说是极大的负担。")]),a._v(" "),e("li",[e("code",[a._v("类SQL数据: 函数即数据")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("_.from(persons).where().select().vallue();")]),a._v(" 已函数形式对数据建模，也就是函数即数据。声明式的描述了数据输出是什么，而不是数据是如何得到的。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('select p.firstname from persons p where ...group by ..\n_.mixin({\n    "select":_.pluck,\n    "from":_.chain,\n    "where":_.filter, \n    "groupby":_.sortByOrder\n});\nconst persons = {}\n')])])])])])]),a._v(" "),e("li",[e("p",[a._v("惰性求值 ???")]),a._v(" "),e("ul",[e("li",[a._v("惰性链:"),e("code",[a._v("_.chain(数据).map().reverse().value()")]),a._v(" 惰性链可以添加一个"),e("code",[a._v("输入对象的状态")]),a._v("，从而能够将这些输入"),e("code",[a._v("转换为所需的输出操作链接在一起")]),a._v("。与简单的数组操作不一样，尽管他是一个复杂的程序，但仍然可以避免创建任何变量，并且有效消除所有循环。"),e("code",[a._v("且在最后调用value之前并不会真正的执行任何操作")]),a._v("。这就是所谓的"),e("code",[a._v("惰性链~")])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("\n")])])]),e("ul",[e("li",[a._v("惰性求值: "),e("code",[a._v("当输入很大但只有一个小的子集有效时，避免不必要的函数调用就是所谓的惰性求值。")]),a._v("惰性求值方法有很多如组合子(alt-类似于 || 先计算fun1如果返回值是false、null、undefined就不再执行 fun2、memoization、shortcut funsion)，但是目的都是一样的，"),e("code",[a._v("即尽可能的推迟求值，直到依赖的表达式被调用。")])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 组合子\nconst alt = _.curry((fun1,fun2,val) => fun1(val) || fun2(val));\nconst showStudent = _,compose(函数体1, alt(xx1, xx2));\nshowStudent({});\n// 记忆\nvar object = {a: \"xx\", b: 2};\nvar values = _.memoize(_.values);\nvalues(object);\nobject.a = '你好';\nconsole.log(values.cache.get(object));\n")])])]),e("ul",[e("li",[a._v("惰性函数: 惰性函数很好理解，"),e("code",[a._v("假如同一个函数被大量范围，并且这个函数内部又有许多判断来来检测函数，这样对于一个调用会浪费时间和浏览器资源，所有当第一次判断完成后，直接把这个函数改写，不在需要判断。")])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("\n")])])])]),a._v(" "),e("li",[e("p",[a._v("高阶函数")]),a._v(" "),e("ul",[e("li",[a._v("定义: "),e("code",[a._v("函数当参数，把传入的函数做一个封装，然后返回这个封装函数,达到更高程度的抽象。")]),a._v("(传函数, return函数)")]),a._v(" "),e("li",[a._v("实现")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var add = function(a,b){\n        return a + b; \n    };\nfunction math(func,array){ \n    return func(array[0],array[1]); \n}\nmath(add,[1,2]); // 3\n")])])]),e("ul",[e("li",[a._v("特点\n"),e("ul",[e("li",[a._v("它是一等公民")]),a._v(" "),e("li",[a._v("它已一个函数作为参数")]),a._v(" "),e("li",[a._v("已一个函数作为返回结果")])])])])]),a._v(" "),e("li",[e("p",[a._v("尾调用优化PTC")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("指函数内部的最后一个动作是函数调用")]),a._v("。"),e("code",[a._v("该调用的返回值，直接返回给函数")]),a._v("。"),e("code",[a._v("函数调用自身，称为递归")]),a._v("。"),e("code",[a._v("如果尾调用自身，就称为尾递归")]),a._v("。递归需要 保存大量的调用记录，很容易发生栈溢出错误，如果使用尾递归优化，将递归 变为循环，那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。")]),a._v(" "),e("li",[a._v("实例:")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function factorial(n, total) { \n    if (n === 1) return total;\n    return factorial(n - 1, n * total); \n} // ES6强制使用尾递归\n")])])]),e("ul",[e("li",[a._v("尾递归问题?\n"),e("ul",[e("li",[e("ol",[e("li",[a._v("问题一:")])]),a._v(" "),e("ul",[e("li",[a._v("尾递归的判断标准是函数运行"),e("code",[a._v("【最后一步】")]),a._v("是否调用自身，")]),a._v(" "),e("li",[a._v("而"),e("code",[a._v("不是")]),a._v(" 是否在函数的【"),e("code",[a._v("最后一行】")]),a._v(" 调用自身,")]),a._v(" "),e("li",[a._v("最后一行调用其他函数 并返回叫尾调用。")])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[a._v("问题二:")])]),a._v(" "),e("ul",[e("li",[a._v("按道理尾递归调用调用栈永远都是更新当前的栈帧而已，这样就完全避免了爆栈的危险。")]),a._v(" "),e("li",[a._v("但是现如今的浏览器并未完全支持原因如下\n"),e("ul",[e("li",[a._v("在引擎层面消除递归是一个隐式的行为，程序员意识不到。")]),a._v(" "),e("li",[a._v("堆栈信息丢失了开发者难已调试。")])])])])]),a._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[a._v("问题三: 既然浏览器不支持我们可以把这些递归写成while~")])])])])])])]),a._v(" "),e("li",[e("p",[e("code",[a._v("闭包")]),a._v(": 保存那个函数的执行上下文(拿到了不应该拿的东西)")]),a._v(" "),e("ul",[e("li",[a._v("虽然外层的 makePowerFn 函数执行完毕，"),e("code",[a._v("栈上的调用帧被释放，但是堆上的作用域并不被释放")]),a._v("，因此 power 依旧可以被 powerFn 函数访问，这样就形成了"),e("code",[a._v("闭包")])]),a._v(" "),e("li",[a._v("实例")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function makePowerFn(power) {\n    function powerFn(base) {\n        return Math.pow(base, power); \n    }\n    return powerFn; \n}\nvar square = makePowerFn(2); \nsquare(3); // 9\n")])])])]),a._v(" "),e("li",[e("p",[a._v("容器、Functor(函子)")]),a._v(" "),e("ul",[e("li",[a._v("我们可以把"),e("code",[a._v("”范畴”")]),a._v("想象成是一个"),e("code",[a._v("容器")]),a._v("，里面包含两样东西。"),e("code",[a._v("值 (value)")]),a._v("、"),e("code",[a._v("值的变形关系，也就是函数")]),a._v("。")]),a._v(" "),e("li",[e("code",[a._v("范畴论使用函数，表达范畴之间的关系。")])]),a._v(" "),e("li",[a._v("函数不仅可以用于"),e("code",[a._v("同一个范畴之中值的转换")]),a._v("，还可以用于将"),e("code",[a._v("一个范畴转成另一个范畴")]),a._v("。这就涉及到了"),e("code",[a._v("函子(Functor)")]),a._v("。")]),a._v(" "),e("li",[a._v("容器是函子, 即有 value。一个东西有value，一个容器是一个范畴。")]),a._v(" "),e("li",[e("code",[a._v("$(...)")]),a._v(" 返回的对象并不是一个原生的 DOM 对象，而"),e("code",[a._v("是对于原生对象的一种封装")]),a._v("，这在"),e("code",[a._v("某种意义上就是一个“容器”(但它并不函数式)")]),a._v("。")]),a._v(" "),e("li",[e("code",[a._v("Functor(函子)遵守一些特定规则的容器类型")]),a._v("。")]),a._v(" "),e("li",[e("code",[a._v("Functor 是一个对于函数调用的抽象")]),a._v("，我们赋予容器自己去调用函数的能力。\n"),e("ul",[e("li",[a._v("把东西装进一个容器，只留出一个接口 "),e("code",[a._v("map")]),a._v(" 给容器外的函数")]),a._v(" "),e("li",[a._v("map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选择何时何地如何操作这个函数")]),a._v(" "),e("li",[a._v("以致于拥有惰性求值、错误处理、异步调用等等非常牛掰的特性")])])]),a._v(" "),e("li",[a._v("理解")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// Container就是容器（有 value 就是容器 ）\nvar Container = function(x) {\n    this.__value = x; \n}\n//函数式编程一般约定，函子有一个of方法\nContainer.of = x => new Container(x);\n//Container.of(‘abcd’); \n// 一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。 \nContainer.prototype.map = function(f){\n    return Container.of(f(this.__value)) \n}\nContainer.of(3)\n    .map(x => x + 1)    // 结果 Container(4)\n    .map(x => 'Result is ' + x);    // 结果 Container('Result is 4')\n")])])]),e("ul",[e("li",[a._v("Maybe 函子\n"),e("ul",[e("li",[a._v("Maybe用于处理错误和异常。\n"),e("ul",[e("li",[a._v("函子接受各种函数，处理容器内部的值。")]),a._v(" "),e("li",[a._v("这里就有一个问容器内部的值可能是一个空值(比如null)，而外部函数未必有处理空值的机制，")]),a._v(" "),e("li",[a._v("如果传入空值，很可能就会出错。")]),a._v(" "),e("li",[a._v("案例")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Functor.of(null).map(function (s) { \n    return s.toUpperCase();\n});\n// TypeError\nclass Maybe extends Functor {\n    map(f) {\n        return this.val ? Maybe.of(f(this.val)) : Maybe.of(null);\n    } \n}\nMaybe.of(null).map(function (s) { \n    return s.toUpperCase();\n});\n// Maybe(null)\n")])])])])])]),a._v(" "),e("li",[a._v("Pointed函子\n"),e("ul",[e("li",[a._v("函子只是一个实现了 map 契约的接口。"),e("code",[a._v("Ponited函子是 一个函子的子集")]),a._v("。")]),a._v(" "),e("li",[a._v("生成新的函子的时候，用了new命令。这实在太不像函数式编程了，因为new命令是面向对象编程的标志。 "),e("code",[a._v("函数式编程一般约定，函子有一个of方法，用来生成新的容器。")])]),a._v(" "),e("li",[a._v("案例")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Functor.of = function(val) { \n    return new Functor(val);\n};\nFunctor.of(2).map(function (two) { \n    return two + 2;\n});\n// Functor(4);\n\n// 数组成为一个Pointed函子 Array.of(“”)\n")])])])])])]),a._v(" "),e("li",[e("p",[a._v("错误处理、Either、AP")]),a._v(" "),e("ul",[e("li",[a._v("Either函子\n* 我们的容器能做的事情太少了，"),e("code",[a._v("try/catch/throw")]),a._v(" 并不是“纯”的，因为它从外部接管了我们的函数，并且在这个函数出错时抛弃了它的返回值。"),e("code",[a._v("分支")]),a._v("\n* Promise 是可以调用 catch 来集中处理错误的。\n* 事实上 Either 并不只是用来做错误处理的，它表示了逻辑或，范畴学里的 coproduc。\n* 条件运算"),e("code",[a._v("if...else")]),a._v("是最常见的运算之一，函数式编程里面，"),e("code",[a._v("使用 Either 函子表达")]),a._v("。 Either 函子内部有两个值:"),e("code",[a._v("左值(Left)和右值(Right)")]),a._v("。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。")]),a._v(" "),e("li",[a._v("AP函子\n"),e("ul",[e("li",[a._v("概念: "),e("code",[a._v("函子里面包含的值，完全可能是函数")]),a._v("。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。")]),a._v(" "),e("li",[a._v("案例:")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("class Ap extends Functor {\n    ap(F) {\n        return Ap.of(this.val(F.val)); \n    }\n}\n")])])])])])]),a._v(" "),e("li",[e("p",[a._v("IO")]),a._v(" "),e("ul",[e("li",[a._v("概念: IO它的 __value 是一个函数。它把不纯的操作(比如 IO、网络请求、DOM)包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，IO 包含的是被包裹的操作的返回值。")]),a._v(" "),e("li",[a._v("IO其实也算是惰性求值。")]),a._v(" "),e("li",[a._v("IO负责了调用链积累了很多很多不纯的操作，带来的复杂性和不可维护性。")]),a._v(" "),e("li",[a._v("案例:")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("import _ from 'lodash'; \nvar compose = _.flowRight;\nvar IO = function(f) {\n        this.__value = f; \n    }\nIO.of = x => new IO(_ => x);\nIO.prototype.map = function(f) {\n    return new IO(compose(f, this.__value)) \n};\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// ES6 方式\nimport _ from 'lodash'; \nvar compose = _.flowRight;\nclass IO extends Monad{ \n    map(f){\n        return IO.of(compose(f, this.__value))   // 被调用的时候执行\n    }\n}\n")])])]),e("ul",[e("li",[a._v("IO 函子")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var fs = require('fs');\nvar readFile = function(filename) {\n    return new IO(function() {\n        return fs.readFileSync(filename, 'utf-8');\n    }); \n};\n\nreadFile('./user.txt').flatMap(tail).flatMap(print)\n// 等同于 \nreadFile('./user.txt').chain(tail).chain(print)\n")])])])]),a._v(" "),e("li",[e("p",[a._v("Monad")]),a._v(" "),e("ul",[e("li",[a._v("类似于拆箱")]),a._v(" "),e("li",[e("code",[a._v("Monad")]),a._v("就是一种设计模式，"),e("code",[a._v("表示将一个运算过程，通过函数拆解成互相连接的多个步骤")]),a._v("。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。")]),a._v(" "),e("li",[e("code",[a._v("Promise 就是一种 Monad")]),a._v("。")]),a._v(" "),e("li",[a._v("Monad 让我们避开了嵌套地狱，可以轻松地进行深度嵌套的函数式编程，比如IO和其它"),e("code",[a._v("异步任务")]),a._v("。")]),a._v(" "),e("li",[a._v("Monad 函子的作用是，总是返回一个单层的函子。它有一个 flatMap 方法, 与 map 方法作用相同, 唯一的区别是如果⽣成了⼀个嵌套函⼦，它会取出后者内部的值，保证返回的永远是⼀个单层的容器，不会出现嵌套的情况。")]),a._v(" "),e("li",[a._v("如果函数 f 返回的是一个函子, 那么 this.map(f) 就会生成一个嵌套的函子。所以, join 方法保证了flatMap 方法总是返回一个单层的函子。这意味着嵌套的函⼦会被铺平(flatten )。")]),a._v(" "),e("li",[a._v("案例:")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v(" Maybe.of( \n    Maybe.of(\n        Maybe.of({name: 'Mulburry', number: 8402}) \n    )\n)\n\nclass Monad extends Functor { \n    join() {\n        return this.val; \n    }\n    flatMap(f) {\n        return this.map(f).join();\n    } \n}\n")])])])])]),a._v(" "),e("h2",{attrs:{id:"当下函数式编程比较火热的库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#当下函数式编程比较火热的库"}},[a._v("#")]),a._v(" 当下函数式编程比较火热的库")]),a._v(" "),e("ol",[e("li",[e("code",[a._v("RxJS")]),a._v(" "),e("ul",[e("li",[a._v("在 Rxjs 中，所有的外部输入(用户输入、网络请求等等)都被视作一种 『事件流』")]),a._v(" "),e("li",[a._v("响应式编程是继承自函数式编程，"),e("code",[a._v("声明式的，不可变的，没有副作用的")]),a._v(" 是函数式编程的三大护法。")]),a._v(" "),e("li",[a._v("在函数中与"),e("code",[a._v("函数作用域之外的一切事物")]),a._v("有交互的就产生了副作用。")])])]),a._v(" "),e("li",[a._v("cycleJS")]),a._v(" "),e("li",[e("code",[a._v("lodashJS")]),a._v("、lazy(惰性求值)\n"),e("ul",[e("li",[a._v("lodash是一个"),e("code",[a._v("具有一致接口、模块化、高性能等特性的JavaScript工具库")]),a._v("，是underscore.js的fork，其最初目标也是“一致的跨浏览器行 为。。。，并改善性能”。")]),a._v(" "),e("li",[e("code",[a._v("lodash采用延迟计算")]),a._v("，意味着我们的"),e("code",[a._v("链式方法在显式或者隐式的 value() 调用之前是不会执行的")]),a._v("，因此lodash可以进行shortcut(捷径) fusion(融合)这样的优化，通过合并链式大大降低迭代的次数，从而大大提升其执行性能。")]),a._v(" "),e("li",[a._v("就如同 jQuery 在全部函数前加全局的$一样，lodash使用全局的_来提供对工具的快速访问。")])])]),a._v(" "),e("li",[a._v("underscoreJS\n"),e("ul",[e("li",[a._v("Underscore 是一个 JavaScript 工具库，它提供了一整套"),e("code",[a._v("函数式编程的实用功能")]),a._v("，但是没有扩展任何 JavaScript 内置对象。")])])]),a._v(" "),e("li",[a._v("ramdajs\n"),e("ul",[e("li",[a._v("ramda 是一个非常优秀的js工具库，跟同类比更函数式主要体现在以下几个原则:\n"),e("ul",[e("li",[a._v("Ramda 的"),e("code",[a._v("数据一律放在最后一个参数")]),a._v('，理念是"function first, data last"。'),e("code",[a._v("R.map(square, [4, 8]) // [16, 64]")]),a._v(" "),e("ul",[e("li",[a._v("ramda里面的提供的函数全部都是curry的也就是说，所有多参数的函数，默认都可以单参数使用。"),e("code",[a._v("R.map(square, [4, 8])=》 R.map(square)([4, 8])")])]),a._v(" "),e("li",[a._v("ramda 推崇 pointfree 简单的说是使用简单函数组合实现一个复杂功能，而不是单独写一个函数操作临时变量。")]),a._v(" "),e("li",[a._v("ramda 有个"),e("code",[a._v("非常好用的参数占位符")]),a._v(" "),e("code",[a._v("R._")]),a._v("大大减轻了函数在 pointfree 过程中参数位置的问题")]),a._v(" "),e("li",[a._v("相比underscore/lodash 感觉要干净很多。")])])])])])])])]),a._v(" "),e("h2",{attrs:{id:"实际应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实际应用场景"}},[a._v("#")]),a._v(" 实际应用场景")]),a._v(" "),e("ol",[e("li",[a._v("易调试、热部署、并发\n"),e("ul",[e("li",[a._v("决定函数执行结果的唯一因素就是它 的返回值，而影响其返回值的唯一因素就是它的参数。")]),a._v(" "),e("li",[a._v("函数式编程不需要考虑"),e("code",[a._v('”死锁"(deadlock)')]),a._v('，因为它不修改变量，所以根本不存在"锁"线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署'),e("code",[a._v('"并发编程"(concurrency)')]),a._v("。")]),a._v(" "),e("li",[e("code",[a._v("函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的")]),a._v("。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。")])])]),a._v(" "),e("li",[a._v("单元测试\n"),e("ul",[e("li",[a._v("严格函数式编程的每一个符号都是对直接量或者表达式结果的引用， 没有函数产生副作用。")])])])]),a._v(" "),e("h2",{attrs:{id:"总结与补充"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结与补充"}},[a._v("#")]),a._v(" 总结与补充")]),a._v(" "),e("ul",[e("li",[a._v("函数式编程被视为我们现有工具箱的一个很自然的补充 —— 它带来了更高的可组合性, 灵活性以及容错性。")]),a._v(" "),e("li",[a._v("Redux 作为一种 FLUX 的变种实现，核心理念也是状态机和函数式编程。")])])])}),[],!1,null,null,null);v.default=t.exports}}]);