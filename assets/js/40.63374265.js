(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{259:function(_,v,e){"use strict";e.r(v);var t=e(0),n=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"php升级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#php升级"}},[_._v("#")]),_._v(" PHP升级")]),_._v(" "),e("h2",{attrs:{id:"面向对象介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面向对象介绍"}},[_._v("#")]),_._v(" 面向对象介绍")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("软件危机")]),_._v("是指落后的软件生成方式无法满足迅速增长的计算机软件需求。")]),_._v(" "),e("li",[_._v("软件工程学: 分为"),e("code",[_._v("结构化方法")]),_._v("和"),e("code",[_._v("面向对象")]),_._v("。结构化方法(按软件周期分为三个阶段: "),e("code",[_._v("分析")]),_._v("、"),e("code",[_._v("设计")]),_._v("和"),e("code",[_._v("编程")]),_._v(")。")]),_._v(" "),e("li",[e("code",[_._v("OOP: 面向对象编程")]),_._v("。其编程的代码更简洁、更易于维护,并具有更强的可重用性。")]),_._v(" "),e("li",[_._v("OOP 达到了软件工程的三个目标: "),e("code",[_._v("重用性")]),_._v("、"),e("code",[_._v("灵活性")]),_._v("、"),e("code",[_._v("扩展性")]),_._v("。")]),_._v(" "),e("li",[_._v("OOP 面向对象编程的三个特点: "),e("code",[_._v("封装")]),_._v("、"),e("code",[_._v("多态")]),_._v("、"),e("code",[_._v("继承")]),_._v("。")])]),_._v(" "),e("h2",{attrs:{id:"类-和-对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类-和-对象"}},[_._v("#")]),_._v(" 类 和 对象")]),_._v(" "),e("ul",[e("li",[_._v("类: 大的范围。例如: 人类。")]),_._v(" "),e("li",[_._v("对象: 具体到某一个实体。例如: 张三。")]),_._v(" "),e("li",[e("code",[_._v("类")]),_._v("是内置的构造函数，"),e("code",[_._v("对象")]),_._v("就是实例。"),e("code",[_._v("对象是，构造函数 new 出来的")]),_._v("(JavaScript)。")]),_._v(" "),e("li",[_._v("面向对象的三个主要特性：\n"),e("ul",[e("li",[_._v("行为: 方法")]),_._v(" "),e("li",[_._v("状态: 属性")]),_._v(" "),e("li",[_._v("标识: 姓名。例如: var s = new Object。其中 s 就是一个标识。")])])])]),_._v(" "),e("h2",{attrs:{id:"php类的格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#php类的格式"}},[_._v("#")]),_._v(" PHP类的格式")]),_._v(" "),e("ol",[e("li",[_._v("简单的格式")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("[修饰符] class 类名 {  // 使用 class 关键字加空格后加类名\n    [成员属性] // 也叫成员变量\n    [成员方法] // 也叫成员函数\n} \n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[_._v("完整的格式")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("[修饰符] class 类名 [extends 父类][implements 接口1[, 接口2...]] {\n    [成员属性] // 也叫成员变量\n    [成员方法] // 也叫成员函数\n} \n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[_._v("成员属性")])]),_._v(" "),e("ul",[e("li",[_._v("格式: "),e("code",[_._v("修饰符 $变量名[=默认值];")]),_._v("  // 例如: public $name='小明';")]),_._v(" "),e("li",[_._v("注意: 成员属性"),e("code",[_._v("不可以")]),_._v("是"),e("code",[_._v("带运算符的表达式")]),_._v("、"),e("code",[_._v("变量")]),_._v("、"),e("code",[_._v("方法或函数")]),_._v("调用。")]),_._v(" "),e("li",[_._v("错误格式:")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("public $var1 = 1+2;\npublic $var2 = self::myStaticMethod();\npublic $var3 = $myVar;\n")])])]),e("ul",[e("li",[_._v("正确定义方式:")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("public $var1 = 100; // 普通数值 (4个标量: 整数、浮点数、布尔、字符串)\npublic $var2 = myConstant;  // 常量\npublic $var3 = self::myStaticMethod;  // 静态属性\npublic $var4 = array(true, false);  //  数组\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[_._v("成员方法")])]),_._v(" "),e("ul",[e("li",[_._v("格式:")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("[修饰符] function 方法名(参数..){\n    [方法体]\n    [return 返回值]\n}\n")])])]),e("ul",[e("li",[_._v("例子:")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("public function say(){ // 人可以说话的方法哦\n    echo '人在说话'; // 方法体\n}\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[_._v("实例化对象")])]),_._v(" "),e("ul",[e("li",[_._v("使用 new 关键字来生成一个对象。")]),_._v(" "),e("li",[e("code",[_._v("$对象名称 = new 类名称();")])]),_._v(" "),e("li",[e("code",[_._v("$对象名称 = new 类名称([参数列表]);")])])]),_._v(" "),e("ol",{attrs:{start:"6"}},[e("li",[_._v("对象中成员的访问")])]),_._v(" "),e("ul",[e("li",[e("code",[_._v("$引用名 = new 类名(构造参数);")])]),_._v(" "),e("li",[e("code",[_._v("$引用名->成员属性 = 赋值; //对象属性赋值")])]),_._v(" "),e("li",[e("code",[_._v("echo $引用名->成员属性; //输出对象的属性")])]),_._v(" "),e("li",[e("code",[_._v("$引用名->成员方法(参数); //调用对象的方法")])])]),_._v(" "),e("ol",{attrs:{start:"7"}},[e("li",[_._v("特殊对象的引用 $this")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("<?php\n    class Person{\n        public $age;\n        public function say($word){\n            echo '我说了什么? '.$word;\n        }\n        public function info(){\n            $this->say('哈哈哈');  // 需要注意的是,调用成员方法或者属性的时候不要用$。\n            return $this->age;\n        }\n    }\n    $o = new Person();\n    $o->age = 20;\n    // $o->say();\n    $result = $o->info();\n    echo '<br />';\n    echo $result;\n?>\n")])])]),e("h2",{attrs:{id:"构造方法和析构方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造方法和析构方法"}},[_._v("#")]),_._v(" 构造方法和析构方法")]),_._v(" "),e("ul",[e("li",[_._v("两个下划线 "),e("code",[_._v("__")]),_._v(", 表示私有的方法。")])]),_._v(" "),e("ol",[e("li",[_._v("构造方法")])]),_._v(" "),e("ul",[e("li",[_._v("构造方法: 在类声明的时候被执行。"),e("code",[_._v("即: 当这个类 new 的时候自动执行")])]),_._v(" "),e("li",[_._v("构造方法的语法格式:")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("[修饰符] function __construct([参数]){\n    程序体\n}    \n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[_._v("析构方法")])]),_._v(" "),e("ul",[e("li",[_._v("析构方法: 下面在没有此类方法调用的时候，就会执行析构方法。"),e("code",[_._v("即: 对象被销毁的时候执行, 没有代码在去运行了")])]),_._v(" "),e("li",[_._v("用途: 可以进行资源的释放操作,例如: 数据库的关闭。")]),_._v(" "),e("li",[_._v("析构方法的语法格式:")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("[修饰符] function __destruct([参数]){\n    程序体\n}   \n")])])]),e("h2",{attrs:{id:"php-面向对象封装性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#php-面向对象封装性"}},[_._v("#")]),_._v(" PHP 面向对象封装性")]),_._v(" "),e("ol",[e("li",[_._v("设置私有成员与私有成员的访问。\n"),e("ul",[e("li",[_._v("封装的修饰符: "),e("code",[_._v("public(公有的,默认)")]),_._v("、"),e("code",[_._v("private(私有的)")]),_._v("、"),e("code",[_._v("protected(受保护的)")])]),_._v(" "),e("li",[_._v("设置私有成员: 只要在声明成员属性或成员方法时, 使用 private 关键字修饰就是实现了对成员的私有封装。")]),_._v(" "),e("li",[_._v("访问私有成员: "),e("code",[_._v("私有的成员方法,不能在类的外部直接访问")]),_._v("。只能在对象的内部方法中使用"),e("code",[_._v("$this")]),_._v("访问。")])])]),_._v(" "),e("li",[_._v("以下几个魔术方法, 只针对"),e("code",[_._v("private、protected")]),_._v("修饰的变量生效。(__两个下划线是私有的)\n"),e("ul",[e("li",[_._v("魔术方法 __set(); "),e("code",[_._v("当外面的元素，对类里面的元素进行设置值的时候，会自动调用。")])]),_._v(" "),e("li",[_._v("魔术方法 __get();"),e("code",[_._v("取这个元素的时候会自动调用")])]),_._v(" "),e("li",[_._v("魔术方法 __isset();  "),e("code",[_._v("对类里面成员属性进行判断的时候调用")]),_._v("。属性是public修饰的话,为 true。属性是private、protected修饰的话,为 false。")]),_._v(" "),e("li",[_._v("魔术方法 __unset();  "),e("code",[_._v("从类外释放属性的时候进行调用")])])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("<?php\n    class Person{\n        private $is='我存在啊';\n        private $name = 'jingjing';\n        private $age = 28;\n        protected $many = 200;\n        \n        private function getAge(){\n            return $this->age;\n        }\n\n        // 被保护的成员方法，不能在类的外部直接被访问\n        protected function getMany(){\n            return $this->many;\n        }\n\n        public function user(){\n            echo $this->$is.'===='.$this->name.'======'.$this->getAge().'====='.$this->getMany();\n        }\n\n        public function __set($key,$value){\n            // 魔术方法的set  只针对 protected private \n            echo $key.'-------'.$value.'<br/>';\n            if($key ==='name' && $value === '小红'){\n                echo '要修改了<br/>';\n                $this->name='小红';\n            }\n        }\n        public function __get($key){\n            if($key === 'age'){\n                return '不想告诉你我的年龄==='.$this->age.'<br/>';\n            }\n        }\n        public function __isset($key){\n            if($key === 'is'){\n                return false;\n            }\n        }\n        public function __unset($key){\n            echo '<br/> 调用__unset()方法';\n            if($key === 'is'){\n                unset($this->is);\n            }\n        }\n    }\n    $p = new Person();\n    $p->name='小红';   // 调用__set()方法\n    echo $p->age;     // 调用__get()方法\n    var_dump(isset($p->is)); // 调用__isset()方法\n    unset($p->is);  // 调用__unset()方法\n    echo $p->is;  // 没有输出的原因是,私有属性。可以调用__get()方法\n    $p->user();  // $this->$is报错。别的属性正常输出。\n?>\n")])])]),e("ul",[e("li",[_._v("正常情况下, 在外面调用私有属性、私有方法会报错。")]),_._v(" "),e("li",[_._v("若要修改私有属性，则调用"),e("code",[_._v("__set()")]),_._v("方法。")]),_._v(" "),e("li",[_._v("若外部输出私有属性，则调用"),e("code",[_._v("__get()")]),_._v("方法。")])])]),_._v(" "),e("li",[e("code",[_._v("封装性")]),_._v(": 就是把对象中的"),e("code",[_._v("成员属性")]),_._v("和"),e("code",[_._v("成员方法")]),_._v("加上访问修饰符,使其尽可能"),e("code",[_._v("隐藏对象的内部细节")]),_._v(",以达到对成员的"),e("code",[_._v("访问控制(切记不是拒绝访问)")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("继承性")]),_._v(": PHP只支持单继承, "),e("code",[_._v("不允许多重继承")]),_._v("(既: 一个子类只能有一个父亲类)。"),e("code",[_._v("可以有多层继承")]),_._v("(即:  一个类可以继承某一个类的子类)。")]),_._v(" "),e("li",[e("code",[_._v("多态性")]),_._v(": 是指在"),e("code",[_._v("父类中定义的属性或行")]),_._v("为"),e("code",[_._v("被子类继承后")]),_._v(", 可以具有不同的数据类型或表现出不同的行为。这使得同一属性或行为在父类及其"),e("code",[_._v("各个子类中具有不同的含义")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("子类中重载父类方法")]),_._v(":\n"),e("ul",[e("li",[_._v("在子类里面允许重写(覆盖)父类中的方法")]),_._v(" "),e("li",[_._v("在子类中, 使用 parent 访问父类中被覆盖的属性和方法")]),_._v(" "),e("li",[_._v("PHP实现重载的办法: "),e("code",[_._v("parent::construct()")]),_._v(" "),e("code",[_._v("parent::fun()")])])])]),_._v(" "),e("li",[e("code",[_._v("抽象方法")]),_._v(": 当类中有一个方法, 没有方法体, 也就是没有花括号, 直接分号结束, 像这样的方法我们叫做抽象方法, 必须使用关键字abstract定义。例如: "),e("code",[_._v("public abstract function fun()")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("抽象类")]),_._v(": 包含"),e("code",[_._v("抽象方法")]),_._v("的类必须是"),e("code",[_._v("抽象类")]),_._v(", 也要使用关键字"),e("code",[_._v("abstract")]),_._v("加以声明。(即使用关键字"),e("code",[_._v("abstract")]),_._v("修饰的类为抽象类)\n"),e("ul",[e("li",[_._v("抽象类的特点: 不能实例化, 也就是不能new成对象。必须由一个子类去继承, 并且把抽象类的抽象方法都实现了")]),_._v(" "),e("li",[_._v("若想使用抽象类, 就必须定义一个类去继承这个抽象类, 并定义覆盖父类的抽象方法(实现抽象方法)。")]),_._v(" "),e("li",[_._v("抽象类不一定非得含有抽象方法。抽象类可以存在普通方法。")]),_._v(" "),e("li",[_._v("例如: "),e("code",[_._v("abstract class Person{}")]),_._v("。")])])]),_._v(" "),e("li",[e("code",[_._v("接口")]),_._v(": PHP不支持多重继承, 也就是说"),e("code",[_._v("每个类只能继承一个父类")]),_._v("。为了解决这个问题, 接口的思想是"),e("code",[_._v("指定一个实现该接口的类必须实现的一系列函数")]),_._v("。\n"),e("ul",[e("li",[_._v("定义格式:")])]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("1. 接口声明的关键字是interface\n2. 接口可以声明常量也可以抽象方法\n3. 接口中的方法都是抽象方法, 不能用abstract去人肉定义\n4. 接口不能被实例化, 需要一个类去实现它\n5. 一个类不能继承多个类  一个类可以实现多个接口\n\ninterface 接口名称 {\n    const $NAME = '小王';   // 常量成员(使用 const 关键字定义)\n    public function study();    // 抽象方法(不需要使用 abstract 关键字), \n}\n\n// 实现接口\nclass Student implements 接口名称 {\n    const data = 3.14;\n    public function study(){\n        echo \"study\";\n    };\n    public function test() {\n        echo self::data;\n    }\n}\n\n$wx = new Student();\necho $wx::NAME; \n")])])]),e("ul",[e("li",[_._v("使用格式: "),e("code",[_._v("class 类名 implements 接口名1,接口名2 {......}")])])])]),_._v(" "),e("li",[e("code",[_._v("抽象类和接口概念的区别")]),_._v(": 当你关注一个"),e("code",[_._v("事物的本质")]),_._v("的时候, 用"),e("code",[_._v("抽象类")]),_._v("。当你关注"),e("code",[_._v("一个操作")]),_._v("的时候, 用"),e("code",[_._v("接口")]),_._v("。\n"),e("ul",[e("li",[_._v("接口是"),e("code",[_._v("对动作")]),_._v("的抽象, 表示这个对象能做什么, 对类的局部行为进行抽象。")]),_._v(" "),e("li",[_._v("抽象类是"),e("code",[_._v("对根源")]),_._v("的抽象, 表示这个类是什么, 对类的"),e("code",[_._v("整体进行抽象")]),_._v(", 对一类事物的抽象描述。")]),_._v(" "),e("li",[_._v("例如: 类(人, 动物)。接口(吃饭, 走路)。")])])]),_._v(" "),e("li",[e("code",[_._v("抽象类和接口本质的区别")]),_._v(":\n"),e("ul",[e("li",[e("code",[_._v("接口")]),_._v("是"),e("code",[_._v("抽象类的变体")]),_._v(", 接口中的所以方法都是抽象的。而"),e("code",[_._v("抽象类是声明方法的")]),_._v(", 存在而不去实现它的类。")]),_._v(" "),e("li",[_._v("接口可以实现多继承, 抽象类不行。")]),_._v(" "),e("li",[_._v("接口定义方法, 不能实现。而抽象类可以实现部分方法。")]),_._v(" "),e("li",[_._v("接口中基本数据类型为static, 而抽象类不是。")]),_._v(" "),e("li",[_._v("接口中不能含有静态代码块以及静态方法, 而抽象类可以含有静态方法和静态代码块。")])])])]),_._v(" "),e("h2",{attrs:{id:"php-常见的关键字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#php-常见的关键字"}},[_._v("#")]),_._v(" PHP 常见的关键字")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("final 关键字")]),_._v(":  只能修饰类和方法。不能使用final关键字来修饰成员属性。\n"),e("ul",[e("li",[_._v("特性:\n"),e("ul",[e("li",[_._v("使用 final 关键字标识的类不能被继承。")]),_._v(" "),e("li",[_._v("使用 final 关键字标识的方法不能被子类覆盖(重写), 是最终版本。")])])]),_._v(" "),e("li",[_._v("目的:\n"),e("ul",[e("li",[_._v("一是为了安全")]),_._v(" "),e("li",[_._v("两个没必要继承或重写")])])])])]),_._v(" "),e("li",[e("code",[_._v("static 关键字")]),_._v(": 表示静态的意思, 用于修饰类的成员属性和成员方法。(即静态属性和静态方法)\n"),e("ul",[e("li",[_._v("类中的静态属性和方法不用实例化(new) 就可以直接使用类名访问。\n"),e("ul",[e("li",[_._v("格式: "),e("code",[_._v("类::$静态属性")]),_._v(" "),e("code",[_._v("类::静态方法")])])])]),_._v(" "),e("li",[_._v("在类的方法中, 不能用 this 来引用"),e("code",[_._v("静态变量")]),_._v("或"),e("code",[_._v("静态方法")]),_._v("。而需要使用 self 来引用。\n"),e("ul",[e("li",[_._v("格式: "),e("code",[_._v("self::静态属性")]),_._v(" "),e("code",[_._v("self::静态方法")])])])]),_._v(" "),e("li",[_._v("静态方法中不可以使用非静态内容。 也就是说不让使用$this。")]),_._v(" "),e("li",[_._v("静态属性是共享的。也就是new很多对象也是共用一个属性。")])])]),_._v(" "),e("li",[e("code",[_._v("单例设计模式")]),_._v(": 单例模式主要作用是保证在面向对象编程设计中, "),e("code",[_._v("一个类只能有一个实例对象存在")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("const 常量")]),_._v(': const 是在一个类中定义常量的关键字, 在PHP中定义常量使用的是"define()"这个函数, 但是在类里面定义常量使用的是"const"这个关键字。\n'),e("ul",[e("li",[_._v("语法:\n"),e("ul",[e("li",[_._v('const ANT = "constant value";     // 关键字')]),_._v(" "),e("li",[_._v("echo self::ANT;   // 类内部访问")]),_._v(" "),e("li",[_._v("echo className::ANT;      // 类外部访问")])])])])]),_._v(" "),e("li",[e("code",[_._v("instanceof 关键字")]),_._v(": 用于检测当前对象实例是否属于某一个类或者这个类的子类。")]),_._v(" "),e("li",[e("code",[_._v("自动加载类")]),_._v(": 当 new 实例化一个不存在的类时, 则自动调用函数"),e("code",[_._v("__autoload()")]),_._v(", 并"),e("code",[_._v("将类名作为参数传入此函数")]),_._v("。可以使用这个实现类的自动加载。")]),_._v(" "),e("li",[e("code",[_._v("class_exists")]),_._v(": 检查类是否定义。")]),_._v(" "),e("li",[e("code",[_._v("get_class_methods")]),_._v(": 返回由类的方法名组成的数组。")]),_._v(" "),e("li",[e("code",[_._v("get_class")]),_._v(": 返回对象的类名。")]),_._v(" "),e("li",[e("code",[_._v("get_object_vars")]),_._v(": 返回由对象属性组成的关联数组。")]),_._v(" "),e("li",[e("code",[_._v("get_parent_class")]),_._v(": 返回对象或类的父类名。")]),_._v(" "),e("li",[e("code",[_._v("is_a")]),_._v(": 如果对象属于该类或该类是此对象的父类, 则返回TRUE。")]),_._v(" "),e("li",[e("code",[_._v("method_exists")]),_._v(": 检测类的方法是否存在。")]),_._v(" "),e("li",[e("code",[_._v("property_exists")]),_._v(": 检测对象或类是否具有该属性。")])]),_._v(" "),e("h2",{attrs:{id:"php-异常处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#php-异常处理"}},[_._v("#")]),_._v(" PHP 异常处理")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("try {\n    if($_GET['num'] == 5){\n        throw new Exception('这是一个系统异常');\n    }\n} catch(Exception $e) {\n    echo \"错误文件为\".$e->getFAILE();\n}\n")])])]),e("h2",{attrs:{id:"php-特点说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#php-特点说明"}},[_._v("#")]),_._v(" PHP 特点说明")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("__")]),_._v("开始的方法名的方法(PHP给我们提供的), 都是在某一时刻不同情况下自动调用执行的方法。")]),_._v(" "),e("li",[e("code",[_._v("__toString")])]),_._v(" "),e("li",[e("code",[_._v("clone")])]),_._v(" "),e("li",[e("code",[_._v("namespace")]),_._v(": 命名空间")])])])}),[],!1,null,null,null);v.default=n.exports}}]);