# 输入网址后发生了什么

参考文章：https://segmentfault.com/a/1190000013662126


## 输入网址后发生了什么
1. 输入网址并回车
2. DNS域名解析
3. 建立TCP链接(客户端 - 服务端 - 客户端)
4. 浏览器发送 HTTP 请求
5. 服务器处理请求
6. 返回响应结果 
7. 关闭TCP连接(客户端 - 服务端 - 服务端- 客户端)

8. 浏览器解析HTML
    * 浏览器通过解析HTML，`生成DOM树`
    * 解析CSS，`生成CSS规则树`
    * 通过DOM树和CSS规则树生成`渲染树`
    * 渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。
    * 浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题。
9. 浏览器布局渲染
    * 根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。
    * HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。
    * 这时就要提到两个重要概念：repaint和reflow
    > repaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。
    > reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。


## 输入网址后发生了什么
1. www.baidu.com 回车
2. 找 IP
    * 为什么: 请求是需要经过**路由器**的转发, 到达服务器。但是路由器只识别32(IPV4)/64(IPV6)位地址
    * 怎么找: 
        * browser -> 联通DNS -> Root DNS(全量) 
        * 域名 和 IP, 以 MAP 的形式进行存储。{domain: 10.10.10.164} 
        * 此次没找到，去上一个 DNS 中找，找到后会缓存下来。
        * 浏览器先找本地缓存, 如果本地未找到, 则逐级查找 DNS 服务器。
3. 发请求
    * 谁去发: 浏览器。本质是 OS 里面的一个进程
    * 怎么发: 
        * client 和 server之间建立管道。`基于 ICP/IP 协议, 创建 socket 连接管道`
            * `Socket` 编程接口
            * CP/IP也必须对外提供编程接口，这就是Socket。
            * 不同语言都有对应的建立Socket服务端和客户端的库
            
        * 7层网络模型 OSI(Open System Interconnection)
            * 自`上往下`分为: 应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。
            * HTTP 协议对应于应用层
            * TCP、UDP协议对应于传输层
            * IP协议对应于网络层
        * TCP/IP 怎么建立链接
            * 建立: 三次握手
            * 断开: 四次挥手
            ![输入网址后发生了什么](三次握手.jpeg)
            **第一次握手**：浏览器向服务器发送请求（SYN=1）,等待服务器确认 <br/>
            **第二次握手**：服务器收到请求并确认，回复一个指令（SYN=1，ACK=1）<br/>
            **第三次握手**：客户端收到服务器的回复指令，并返回确认（ACK=1）<br/>

            **服务器返回html文档之后，浏览器的渲染引擎开始dom解析过程**


            完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。通信结束客户端和服务端就断开连接，需要经过四次分手确认。<br/>

            **第一次分手**：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br/>
            **第二次分手**：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；<br/>
            **第三次分手**：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；<br/>
            **第四次分手**：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。<br/>
        * HTTP 是什么？它和 TCP/IP 协议有什么不同
            * 他们都是协议, 但是工作在不同的网络层
            * 关于TCP/IP和HTTP协议的关系，“我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。如果想要使传输的数据有意义，则必须使用到应用层协议。应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。
4. 数据传输
    * client发送: request (path: /api/user. domain: www.baidu.com. Header session Cookie)
    * server 处理请求: 服务端处理逻辑
    * server 返回: response(header.body.Content-Type: html或application/json) 
5. 渲染
    * 服务器返回`html文档`之后，浏览器的渲染引擎开始`dom解析`过程
    * `构建DOM树`--> `渲染树(Render tree)` --> `布局render树`--> `绘制render树`
    * 构建DOM树
        * 渲染引擎会调用`html解析器`开始解析html，将html的标签`解析成dom树`，如果遇到静态资源，`link标签则去请求相应的资源`，遇到`script标签就会调用js引擎解释并执行`
        * 解析dom树的过程：通过网络请求获取的html网页或资源从`字节流解码成字符流`，然后通过词法分析器解析成词语，之后经过`语法分析器构建成节点`，最后这些`节点组成一颗dom树`（当dom树构建完成之后，`webkit会触发DOMContentLoaded事件`，jquery的dom ready源码实现也用到这个事件，当所有资源全都加载完毕之后会触发onload事件）
    * 渲染树(Render tree)
        * dom树解析完成之后，`渲染引擎`调用`css解释器`, 根据css规则为每个dom树节点计算css样式信息，`构建渲染树 (Render tree)`
        * render tree的过程：`渲染引擎调用css解释器`，根据css规则(解析外部或者内部引用额样式表)，解析出样式信息，构建render tree，渲染树会忽略掉不需要被渲染的元素(display:none,head,meta...)
    * 布局树（render layer）
        * 构建render tree之后，每个元素并不知道自己的大小颜色等样式和位置信息
        * 渲染引擎根据包含块和盒模型来计算元素的大小位置等信息，这就是布局计算（排版）。
    * 绘制render树
        * 绘制render树
6. 执行js、css




## 浏览器渲染流程

1. 浏览器主要组件结构
    ![浏览器渲染流程](浏览器主要组件结构.png)
2. 渲染引擎——webkit和Gecko
    ![浏览器渲染流程](渲染引擎.png)
    * Firefox使用Geoko —— `Mozilla`自主研发的渲染引擎。
    * Safari和Chrome都使用 `webkit`
3. 关键渲染路径
    * 关键渲染路径是指浏览器从最初接收请求来的 `HTML、CSS、javascript`等资源，然后`解析、构建树、渲染布局、绘制`，最后呈现给客户能看到的界面这整个过程。
    * 所以浏览器的渲染过程主要包括以下几步：
        * 解析HTML生成DOM树
        * 解析CSS生成CSSOM规则树
        * 将DOM树与CSSOM规则树合并在一起生成渲染树
        * 遍历渲染树开始布局，计算每个节点的位置大小信息
        * 将渲染树每个节点绘制到屏幕
4. 构建DOM树
    * 当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。
    * 需要注意的是, DOM树的生成过程中可能会被JS的加载执行阻塞
    * DOM树的生成过程中不会被CSS加载执行阻塞，CSS只阻塞了DOM的渲染而不会影响其生成
5. 构建CSSOM规则树
    * 浏览器解析CSS文件并生成CSS规则树，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。
    * CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。
    * 
6. 渲染阻塞
    * 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建DOM。每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。
    * 所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则
        * CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
        * JS置后：我们通常把JS代码放到页面底部，且JavaScript 应尽量少影响 DOM 的构建。
    * 当解析html的时候，会把新来的元素插入dom树里面，同时去查找css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。
    * 例如： div p {font-size: 16px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染）。
        * 所以，我们平时写CSS时，尽量用id和class，千万不要过渡层叠。
    
7. 构建渲染树
    * 通过DOM树和CSS规则树我们便可以构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的CSS样式规则并应用。
    * 渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与DOM树的最大区别所在。渲染树是用于显示，那些不可见的元素当然就不会在这棵树中出现了，譬如。除此之外，display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这棵树里头的。
8. 渲染树布局   
    * 布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。
9. 渲染树绘制
    * 在绘制阶段，遍历渲染树，调用渲染器的`paint()`方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。
    * reflow与repaint：
        * 根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。
        * `replaint - 重画`：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。
        * `reflow - 重排(回流)`： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。
        * 所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。
        * display:none 会触发 reflow，visibility: hidden属性并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框，所以visibility:hidden 只会触发 repaint，因为没有发生位置变化。
        * 有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。



