# 正则基础知识点

* 在线正则匹配工具: `https://tool.oschina.net/regex/`



* 贪婪匹配模式
    * 正则表达式去匹配时，会`尽量多的匹配`符合条件的内容
    * 标识符: `+，?，*，{n}，{n,}，{n,m}`
        * `*` 匹配前面的子表达式`零次或多次`。等价于 {0,}。   
        * `+` 匹配前面的子表达式`一次或多次`。
        * `?` 匹配前面一个表达式 `0 次或者 1 次`。等价于 {0,1}。
        * `{n}` n 是一个正整数，匹配了前面一个字符`刚好出现了 n 次`。
        * `{n,}` n是一个正整数，匹配前一个字符`至少出现了n次`。
    * 匹配时，如果遇到上述标识符，代表是`贪婪匹配，会尽可能多的去匹配内容`


* 重复次数
    * `*` 表示重复任意次数
    * `?` 表示重复0次或一次
    * `{n,m}`表示重复n到m次
    * `{n,}` 表示至少重复n次


* 唯一次数
    * `.` 代表所有的单个字符, 除了\n\r

* 10个经典的正则
    * `(x)`: `捕获括号`模式匹配的用法。
        * 主要用来`匹配某一类字符串并记住匹配项`。
        * `(x)` 中有组的概念，可以用`$`匹配。
        * 案例: 模式`/(foo) (bar) \1 \2/`中的` ‘(foo)’ 和 ‘(bar)’ `匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 `\1 和 \2`匹配`字符串的后两个单词`。注意 `\1、\2、\n `是用在`正则表达式的匹配环节`。在正则表达式的`替换环节`，则要使用像 `$1、2 、n 这样的语法`，例如，'bar foo'.replace( /(bar) (foo)/, ‘$2 $1’ )。输出: foo bar。
        * 完整案例: 
        ```javascript
        var str = 'xuxi is xuxi is'
        var reg = /(xuxi) (is) \1 \2/g
        reg.test(str)  // true    (1)
        var result = str.replace(reg, '$2 $1')  // is xuxi
        ```
    * `(?:x)`: `非捕获括号`模式匹配。
        * 主要用来`匹配某一类字符串但不记住匹配项`。
        * 能够定义为与正则表达式运算符`一起使用的子表达式`。
        * 它匹配`一组字符`但是`并记不住该字符`,一般用来`判断某类字符是否存在于某字符串中`。
        * 案例: 表达式 `/(?:foo){1,2}/`。如果表达式是 /foo{1,2}/，{1,2}将只对 'foo' 的最后一个字符 'o' 生效。如果使用非捕获括号，则{1,2}`会匹配整个 'foo' 单词`。
        * 完整案例:
        ```javascript
        let str = 'xuxixuxi'
        let reg = /(?:xuxi){1,2}/g
        reg.test(str)  // true    (1)
        ```
    * `x(?=y)`: 先行断言。
        * 匹配`'x'仅仅当'x'后面跟着'y'`。
        * 完整案例: `/王(?=者)/`会`匹配到"王"仅当它后面跟着"者"`。但是"者"不属于匹配结果的一部分.
        ```javascript
        let str = '王者融化'
        let reg = /王(?=者)/
        reg.test(str)  // true    (1)
        let result = str.replace(reg,'hello'); // result -> hello者融化
        ```
    * `(?<=y)x`: 后行断言
        * 匹配`'x'仅当'x'前面是'y'`.
        * 完整案例:  `/(?<=xuxi)A/`会匹配到`A仅当它前面为xuxi`.但是xuxi不属于匹配结果的一部分.
        ```javascript
        let str = 'xuxiAjing';
        let reg = /(?<=xuxi)A/;
        reg.test(str)  // true    (1)
        let result = str.replace(reg,'KKK'); // result -> xuxiKKKjing
        ```
    * `x(?!y)`: 正向否定查找
        * 仅仅当`'x'后面不跟着'y'时匹配'x'`。
        * 完整案例: `也就是说匹配一个或多个数字后面没有.`
        ```javascript
        let str = '3.1415'
        let reg = /\d+(?!\.)/
        reg.exec(str)  // [1415] (1)  ["1415", index: 2, input: "3.1415", groups: undefined]
        let result = str.replace(reg,'999'); // result -> 3.999
        ```
        * 解释: 其中`/\d+(?!.)/`匹配一个或多个数字,当且仅当它后面没有小数点时, 所以(1)中执行后会匹配到1415而不是3.1415
    * `(?<!y)x`: 反向否定查找
        * 仅仅`当'x'前面不是'y'时匹配'x'`.
        * 完整案例: `也就是说匹配一个或多个数字前面没有.`
        ```javascript
        let str = '3.1415'
        let reg = /(?<!\.)\d+/
        reg.exec(str)  // [3] (1)  ["3", index: 0, input: "3.1415", groups: undefined]
        let result = str.replace(reg, '000'); // result -> 000.1415
        ```
        * 解释: `/(?<!.)\d+/匹配一个或多个数字`,当且仅当前面字符不是.时,此时将匹配3.
    * `[xyz]和[^xyz]`: 字符集合和反向字符集合的用法
        * `[xyz]`: `一个字符集合`。`匹配方括号中的任意字符`，包括转义序列。可以使用破折号（-）来指定一个字符范围。
        * `[^xyz]`: `一个反向字符集`。也就是说，它`匹配任何没有包含在方括号中的字符`。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。
        * 完整案例1: 
        ```javascript
        let str = 'abcd'
        let reg1 = /[a-c]+/
        let reg2 = /[^c]$/
        reg1.test(str)  // true    (1)
        reg2.exec(str)  // ["d", index: 3, input: "abcd", groups: undefined] (2)

        let result1 = str.replace(reg1, '00');    // result1 -> 00d
        let result2 = str.replace(reg2, 'kk');    // result1 -> abckk
        ```
        * 完整案例2: 
        ```javascript
        let str = 'abcd'
        let reg1 = /[a-c]+/
        let reg2 = /[^d]$/
        reg1.test(str)  // true    (1)
        reg2.test(str)  // false    (2)

        (1)中将返回true,因为字符串中包含a-c中的字符
        (2)中奖返回false, 因为字符串结尾为d, 但正则reg2需要匹配结尾不为d的字符串.
        ```
    * `\b和\B`: 词边界和非单词边界匹配.
        * 
        * 完整案例:
        ```javascript 
        let str = 'xuxi'
        let reg1 = /xi\b/
        let reg2 = /xu\B/
        reg1.exec(str)  // [xi]    (1)
        reg2.exec(str)  // [xu]    (2)
        ```
        * 解释: (1)中匹配到了单词边界,即xi, 为该字符串的末尾.(2)中应为xu为非单词边界,所以会被其匹配到.
    * `\s和\S`: 空白字符/非空白字符匹配.
        * `\s`: 匹配一个空白字符，包括空格、制表符、换页符和换行符.
        * `\S`: 匹配一个非空白字符
        * 完整案例:
        ```javascript 
        let str = 'xuxi is'
        let reg1 = /.*\s/g
        let reg2 = /\S\w*/g
        reg1.exec(str)  // [xuxi]    (1)
        reg2.exec(str)  // [xuxi]    (2)
        ```
        * 解释: (1)和(2)中执行之后都将匹配xuxi, 一个是空白字符之前的匹配, 一个是非空白字符的匹配.
    * `\w和\W`: 单字字符/非单字字符匹配.
        * `\w`: 匹配一个`单字字符（字母、数字或者下划线）`。等价于 [A-Za-z0-9_]。
        * `\W`: 匹配一个`非单字字符`。等价于 [^A-Za-z0-9_]



* 正则表达式中的特殊字符
    * `\`: 转义
    * `^`: 匹配输入的`开始`。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。
    * `$`: 匹配输入的`结束`。如果多行标志被设置为 true，那么也匹配换行符前的位置。
    * `*`: 匹配前一个表达式 `0 次或多次`。等价于 {0,}。
    * `+`: 匹配前面一个表达式 `1 次或者多次`。等价于 {1,}。
    * `?`: 匹配前面一个表达式 `0 次或者 1 次`。等价于 {0,1}。
    * `.`:（小数点）默认`匹配除换行符之外的任何单个字符`。
    * `(x)`: `模式匹配的用法`。
    * `(?:x)`: `非捕获括号的模式匹配`。
    * `x(?=y)`: `先行断言`。
    * `(?<=y)x`: `后行断言`。
    * `x(?!y)`: `正向否定查找`。
    * `(?<!y)x`: `反向否定查找`。
    * `x|y`: 匹配‘x’`或`者‘y’。
    * `{n}`: n 是一个正整数，匹配了`前面一个字符刚好出现了 n 次`。
    * `{n,}`: n是一个正整数，匹配前一个字符`至少出现了n次`。
    * `{n,m}`: n 和 m 都是整数。匹配`前面的字符至少n次，最多m次`。如果 n 或者 m 的值是0， 这个值被忽略。
    * `[xyz]`: 一个字符集合。匹配方括号中的任意字符，包括转义序列。可以使用破折号（-）来指定一个字符范围
    * `[^xyz]`: 一个反向字符集。也就是说，`匹配任何没有包含在方括号中的字符`。可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。
    * `[\b]`: 匹配一个退格(U+0008)。
    * `\b`:匹配一个`词的边界`。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。`例如, \[a-z]\b\ 匹配"abc def" 中的 'c 和 f'`
    * `\B`: 匹配一个`非单词边界`。匹配如下几种情况：
        * 字符串第一个字符为非“字”字符
        * 字符串最后一个字符为非“字”字符
        * 两个单词字符之间
        * 两个非单词字符之间
        * 空字符串
        * `例如, \[a-z]\B\ 匹配"abc def" 中的 'ab 和 de'`
    * `\cX`:
    * `\d`: 匹配一个`数字`。等价于[0-9]。
    * `\D`: 匹配一个`非数字字符`。等价于[^0-9]。
    * `\f`: 匹配一个`换页符` (U+000C)。
    * `\n`: 匹配一个`换行符` (U+000A)。
    * `\r`: 匹配一个`回车符` (U+000D)。
    * `\s`: 匹配一个`空白字符，包括空格、制表符、换页符和换行符`。等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。`例如, /\s\w*/ 匹配"foo bar."中的' bar'。`
    * `\S`: 匹配一个`非空白字符`。等价于 [^ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。`例如，/\S\w*/ 匹配"foo bar."中的'foo'。`
    * `\t`: 匹配一个`水平制表符` (U+0009)。
    * `\v`: 匹配一个`垂直制表符` (U+000B)。
    * `\w`: 匹配一个`单字字符（字母、数字或者下划线）`。等价于 [A-Za-z0-9_]。
    * `\W`: 匹配一个`非单字字符`。等价于 [^A-Za-z0-9_]。例如, /\W/ 或者 /[^A-Za-z0-9_]/ 匹配 "50%." 中的 '%'。
    * `\n`: 在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。
    * `\0`: `匹配 NULL`（U+0000）字符， 不要在这后面跟其它小数，因为 \0`<digits>` 是一个八进制转义序列。
    * `\xhh`: 匹配一个两位十六进制数（\x00-\xFF）表示的字符。
    * `\uhhhh`: 匹配一个四位十六进制数表示的 UTF-16 代码单元。
    * `\u{hhhh} 或 \u{hhhhh}`:（仅当设置了u标志时）匹配一个十六进制数表示的 Unicode 字符。

* 使用正则表达式
    * `正则RegExp`的方法有`exec` 和 `test` 方法。
        * `exec`:  一个在字符串中执行查找匹配的RegExp方法，它`返回一个数组`（未匹配到则返回 null）。
        * `test`:  一个在字符串中测试是否匹配的RegExp方法，它`返回 true 或 false`。
    * `String` 的方法有的 `match`、`replace`、`search` 和 `split` 方法。
        * `match`: 一个在字符串中执行查找匹配的String方法，它`返回一个数组`，在未匹配到时会返回 null。
        * `matchAll`:  一个在字符串中执行查找所有匹配的String方法，它`返回一个迭代器（iterator）`。
        * `search`: 一个在字符串中测试匹配的String方法，它`返回匹配到的位置索引`，或者在失败时返回-1。
        * `replace`: 一个在字符串中执行查找匹配的String方法，并且`使用替换字符串替换掉匹配到的子字符串`。
            ```javascript
            - 下面的脚本使用replace()方法来转换字符串中的单词。
            - 在匹配到的替换文本中，脚本使用替代的$ 1,$ 2表示第一个和第二个括号的子字符串匹配。

            var re = /(\w+)\s(\w+)/;
            var str = "John Smith";
            var newstr = str.replace(re, "$2, $1");
            console.log(newstr);  // "Smith, John"
            ```
        * `split`: 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。
* 正则表达式标志
    * `g`: 全局搜索。
    * `i`: 不区分大小写搜索。
    * `m`: 多行搜索。
    * `s`: 允许 . 匹配换行符。
    * `u`: 使用unicode码的模式进行匹配。
    * `y`: 执行“粘性(sticky)”搜索,匹配从目标字符串的当前位置开始。

* 经典案例
    * 每3位字符串加一个逗号。例如: 存折中数字的写法。
        * var result = '100000'.replace(/\B(?=(\d{3})+(?!\d))/g,','); // 结果：100,000
        * var result = '123456'.replace(/(?=(\B)(\d{3})+$)/g, ',');  // 结果：123,456
    * 去除字符串内指定元素的标签
    ```javascript
    function trimTag(tagName, htmlStr) {
        let reg = new RegExp(`<${tagName}(\\s.*)*>(\\n|.)*<\\/${tagName}>`, "g")
        return htmlStr.replace(reg, '')
    }
    ```
    * 短横线命名转驼峰命名
    ```javascript
    // 短横线转驼峰命名, flag = 0为小驼峰, 1为大驼峰
    function toCamelCase(str, flag = 0) {
        if(flag) {
            return str[0].toUpperCase() + str.slice(1).replace(/-(\w)/g, ($0, $1) => $1.toUpperCase())
        }else {
            return str.replace(/-(\w)/g, ($0, $1) => $1.toUpperCase())
        }
    }
    ```
    * 实现一个简单的模板引擎
        待学习: 学习链接http://www.alloyteam.com/2016/10/implement-a-simple-template-engine/
    * 去除字符串中的空格符
    ```javascript
    function trimAll(str) {
        return str.replace(/\s*/g,"")
    }
    ```
    * 判断指定格式的数据输入合法性
    ```javascript
    function numCheck(str, specialNum) {
        if(str.indexOf(',') > -1) {
            return str.splite(',').every(item=>this.numCheck(item));
        } else {
            return str.split(specialNum).length === 2;
        }
    }
    ```
    * 去除url参数字符串中值为空的字段
    ```javascript
    // 去除url参数字符串中值为空的字段
    const trimParmas = (parmaStr:string = '') => {
        return parmaStr.replace(/((\w*?)=&|(&\w*?=)$)/g, '')
    }
    ```
    * 将浏览器参数字符串转化为参数对象
    ```javascript
    function unParams(params = '?a=1&b=2&c=3') {
        let obj = {}
        params && params.replace(/((\w*)=([\.a-z0-9A-Z]*)?)?/g, (m,a,b,c) => {
            if(b || c) obj[b] = c
        })
        return obj
    }
    ```
    * 计算字符串字节数
    ```javascript
    /**
    * 计算字符串字节数
    * @param str
    * @desc 一个中文占2个字节, 一个英文占一个字节
    */
    function computeStringByte(str) {
        let size = 0,
        strArr = str.split(''),
        reg = /[\u4e00-\u9fa5]/   // 判断是否为中文
        for(let i = strArr.length; i--; i>=0) {
            if(reg.test(strArr[i])) { 
            size+= 2
            }else {
            size += 1
            }
        }
        return size
    }
    ```
    * 匹配是否包含中文字符
    ```javascript
    function hasCn(str) {
        let reg = /[\u4e00-\u9fa5]/g
        return reg.test(str)
    }
    ```
    * 实现搜索联想功能
    ```javascript
    function searchLink(keyword) {
        // 模拟后端返回数据
        let list = ['abc', 'ab', 'a', 'bcd', 'edf', 'abd'];
        let reg = new RegExp(keyword, 'i');
        return list.filter(item => reg.test(item))
    }
    ```










