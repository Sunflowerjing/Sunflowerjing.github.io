# 快速排序

* 快速排序的思想:
    * 在数据集之中，选择一个元素作为`基准`（pivot）。
    * 所有小于`基准`的元素, 都移到`基准`的左边; 所有大于`基准`的元素, 都移到`基准`的右边。
    * 对`基准`左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。


## 快速排序的实现方式
```
function quickSort(arr) {
    if (arr.length <= 1) { return arr; }  // 检查数组的元素个数，如果小于等于1，就返回。

    // 选择"基准"（pivot）, 并将其与原数组分离, 再定义两个空数组, 用来存放一左一右的两个子集。
    var pivotIndex = Math.floor(arr.length / 2);
    var pivot = arr.splice(pivotIndex, 1)[0];  // 将“基准”从arr数组删除, 将arr数组的“基准”赋值给pivot
    var left = [];
　　 var right = [];

    // 开始遍历数组, 小于"基准"的元素放入左边的子集, 大于基准的元素放入右边的子集。
    for (var i = 0; i < arr.length; i++){
　　　　if (arr[i] < pivot) {
　　　　　　left.push(arr[i]);
　　　　} else {
　　　　　　right.push(arr[i]);
　　　　}
　　}

    // 使用递归不断重复这个过程，就可以得到排序后的数组。 
    return quickSort(left).concat([pivot], quickSort(right));
}   
```


## 孙同学
```js
/**
 * 快速排序
 * @param nums  数组
 * @param left  排序的左边界索引
 * @param right 排序的右边界索引
 */
 function qsort(nums, left, right) {
    if (left >= right) return;

    var pivot = nums[left], i = left, j = right;
    while (i < j) {
        while (i < j && pivot < nums[j]) {
            --j
        };
        nums[i] = nums[j];

        while (i < j && pivot >= nums[i]) {++i};
        nums[j] = nums[i];
    }
    nums[i] = pivot;
    qsort(nums, left, i-1);
    qsort(nums, i+1, right);
}

var v;
v = [3, 2, 1, 3, 4, 0, -1, 8, 9, 1, 0];
qsort(v, 0, v.length - 1);
console.log(v);

v = [];
qsort(v, 0, v.length - 1);
console.log(v);

v = [5, 4, 3, 2, 1];
qsort(v, 0, v.length - 1);
console.log(v);
```