# 数组方法

* `注意`: `splice()` 方法与 `slice()` 方法的作用是不同的，`splice() 方法会直接对数组进行修改`。


1. `splice()`: 方法向/从数组中添加/删除项目, 然后返回被删除的项目。
    * 该方法`会改变原始数组`.
    * `arrayObject.splice(index,howmany,item1,.....,itemX)`
        * `index`: 必需。整数，规定添加/删除项目的`位置`。
        * `howmany`: 必需。要`删除的项目数量`。如果设置为 0, 则不会删除项目。
        * `item1, ..., itemX`: 可选。向数组`添加的新项目`。
    * 返回值
        * Array, 包含被删除项目的新数组，如果有的话。


2. `slice()`: 方法可从已有的数组中返回`选定的元素`
    * 该方法并`不会修改数组`，而是返回一个子数组。
    * `arrayObject.slice(start,end)`
        * `start`: 必需。规定从何处开始选取。
        * `end`: 可选。规定从何处结束选取。
    * 返回值
        * 返回一个`新的数组`，包含从` start 到 end （不包括该元素）`的 arrayObject 中的元素。
    * 案例：
    ```javascript
    [11,22,33,44].slice(1,3);  =>  [22, 33]
    ```

3. `shift()`: 删除数组的第一个元素，并返回第一个元素的值。
    * 该方法会改变数组的长度。
    * 要`删除并返回数组的最后一个元素`，请使用 `pop()` 方法。
    * 案例:
    ```javascript
    const array1 = [1, 2, 3];
    const firstElement = array1.shift();

    console.log(array1);  // Array [2, 3]
    console.log(firstElement); // 1
    ```
4. `forEach()`: 用于遍历数组，无返回值
    * 在forEach使用 `return` 不好用。
    * 例子: 将数组中的每一项翻倍
    ```javascript
    var arr = [1,-2,3,4,-5];
    arr.forEach(function(item,index,array){
        array[index] = item * 2;
    });
    console.log(arr);   // [2,-4,6,8,-10]
    ```
5. `map()`: 用于遍历数组，返回处理之后的新数组
    * 例子: 该方法`与forEach()的功能`类似，只不过`map()具有返回值`, 会返回一个`新的数组`，这样`处理数组后也不会影响到原有数组`。
    ```javascript
    var newArr = arr.map(function(item,index,array){
        return item * 2;
    });
    console.log(newArr);   // [2,-4,6,8,-10]
    ```
6. `flatMap()`: 用于映射函数映射每个元素，然后将结果压缩成一个新数组
    * 例子:  
    ```javascript
    var arr = [1, 2, 3, 4];
    arr.flatMap(x => [x * 2]); // [2, 4, 6, 8]
    ```
    
6. `every()`: 用于判断`数组中的每一项元素是否都满足条件`，返回一个布尔值
    * 例子: 判断数组arr中的元素是否都为正数
    ```javascript
    var arr = [1,-2,3,4,-5];
    var isEvery = arr.every(function(item,index,array){
        return item > 0;
    });
    console.log(isEvery);   // false
    ```
7. `some()`: 用于判断`数组中的是否存在满足条件`的元素，返回一个布尔值
    * 例子: 判断数组arr中是否存在负数元素
    ```javascript
    var arr = [1,-2,3,4,-5];
    var isSome = arr.some(function(item,index,array){
        return item < 0;
    });
    console.log(isSome);   // true
    ```
8. `filter()`: 用于`筛选数组中满足条件的元素，返回一个筛选后的新数组`
    * 例子: 要筛选出数组arr中的所有负数
    ```javascript
    var minus = arr.filter(function(item,index,array){
        return item < 0;
    });
    console.log(minus);   // [-2, -5]
    ```
9. 补充: `forEach()`、`map()`、`every()`、`some()`、`filter()`, 以上五大方法除了传递一个`匿名函数作为参数之外`，还可以传第二个参数，该`参数用于指定匿名函数内的this指向`
    * 例子: 只传一个匿名函数
    ```javascript
    arr.forEach(function(item,index,array){
        console.log(this);  // window
    });
    ```
    * 例子: 传两个参数
    ```javascript
    arr.forEach(function(item,index,array){
        console.log(this);  // [1, -2, 3, 4, -5]
    },arr);
    ```
    * 总结: 
    > 1. forEach()无返回值，map()和filter()返回新数组，every()和some()返回布尔值
    > 2. 匿名函数中this指向默认为window，可通过传第二参数来更改之
    > 3. 五种遍历方法均为ES5方法

4. map，filter，reduce，是三种对集合进行操作的方式
    > 1. 三者都会对集合遍历，不同的是，map和filter给出当前元素，
    > 2. reduce 会给出当前元素和之前元素处理的合集，这个合集可以不只是简单的加减乘除。



## reduce 的用法
``` javascript
array.reduce(function(total, currentValue, currentIndex, arr), initialValue);


total: 必需。初始值, 或者计算结束后的返回值。
currentValue： 必需。当前元素。
currentIndex： 可选。表示当前正在处理的数组元素的索引，若提供 initialValue 的值，则索引为0，否则索引为1。
arr： 可选。当前元素所属的数组对象。
initialValue: 可选。传递给函数的初始值，相当于total的初始值。
```

* `reduce()` 是数组的归并方法, 与`forEach()、map()、filter()`等迭代方法一样都会对数组每一项进行遍历，但是r`educe() 可同时将前面数组项遍历产生的结果与当前遍历项进行运算`，这一点是其他迭代方法无法企及的




1. 使用场景一: 数组求和
```javascript
const arr = [12, 34, 23];
const sum = arr.reduce((total, num) => total + num);

<!-- 设定初始值求和 -->
const arr = [12, 34, 23];
const sum = arr.reduce((total, num) => total + num, 10);  // 以10为初始值求和

<!-- 对象数组求和 -->
var result = [
    { subject: 'math', score: 88 },
    { subject: 'chinese', score: 95 },
    { subject: 'english', score: 80 }
];
const sum = result.reduce((prev, cur) => prev + cur.score, 0); 
const sum = result.reduce((prev, cur) => prev + cur.score, -10);  // 总分扣除10分
```

2. 使用场景二: 数组最大值
```javascript
const arr = [23,123,342,12];
const max = arr.reduce((pre, cur) => pre > cur ? pre : cur)
```

3. 求字符串中字母出现的次数
```javascript
const str = 'sfhjasfjgfasjuwqrqadqeiqsajsdaiwqdaklldflas-cmxzmnha';
const res = str.split('').reduce((accumulator, cur, i, arr) => {
    accumulator[cur] ? accumulator[cur]++ : accumulator[cur] = 1; 
    return accumulator;
}, {});
```

4. 数组转数组
```javascript
<!-- 按照一定的规则转成数组 -->
const arr = [2, 3, 4, 5, 6]; // 每个值的平方
const newarr = arr.reduce((accumulator, cur) => {
    accumulator.push(cur * cur); 
    return accumulator;
}, []);
```

5. 数组转对象
```javascript
const streams = [{name: '技术', id: 1}, {name: '设计', id: 2}];
const obj = streams.reduce((accumulator, cur) => {
    accumulator[cur.id] = cur; 
    return accumulator;
}, {});   
```

6. 扁平一个多维数组
```javascript
var arr = [[1, 2, 8], [3, 4, 9], [5, 6, 10]];
var res = arr.reduce((x, y) => x.concat(y), []);
```

6. 数组去重
```javascript
const arr = [6, 2,3,1,2,3,4,5,1]
const newArr = arr.reduce(function (prev, cur) {
    prev.indexOf(cur) === -1 && prev.push(cur);
    return prev;
},[]);
```







6. 高级用法: 多维的叠加执行操作
   * 各科成绩占比重不一样， 求结果
   ```javascript
    var result = [
        { subject: 'math', score: 88 },
        { subject: 'chinese', score: 95 },
        { subject: 'english', score: 80 }
    ];
    var dis = {
        math: 0.5,
        chinese: 0.3,
        english: 0.2
    };
    var res = result.reduce((accumulator, cur) => {
        return dis[cur.subject] * cur.score + accumulator
    }, 0);
   ```
   * 商品对应不同国家汇率不同，求总价格
    ```javascript
    var prices = [{price: 23}, {price: 45}, {price: 56}];
    var rates = {
        us: '6.5',
        eu: '7.5',
    };
    var initialState = {usTotal:0, euTotal: 0};
    var res = prices.reduce((accumulator, cur1) => Object.keys(rates).reduce((prev2, cur2) => {
    console.log(accumulator, cur1, prev2, cur2);
    accumulator[`${cur2}Total`] += cur1.price * rates[cur2];
    return accumulator;
    }, {}), initialState);

    var manageReducers = function() {
    return function(state, item) {
        return Object.keys(rates).reduce((nextState, key) => {
            state[`${key}Total`] += item.price * rates[key];
            return state;
        }, {});
    }
    };
    var res1= prices.reduce(manageReducers(), initialState);
    ```







