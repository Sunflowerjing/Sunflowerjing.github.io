# 数组方法

* `注意`: `splice()` 方法与 `slice()` 方法的作用是不同的，`splice() 方法会直接对数组进行修改`。


1. `splice()`: 方法向/从数组中添加/删除项目, 然后返回被删除的项目。
    * 该方法`会改变原始数组`.
    * `arrayObject.splice(index,howmany,item1,.....,itemX)`
        * `index`: 必需。整数，规定添加/删除项目的`位置`。
        * `howmany`: 必需。要`删除的项目数量`。如果设置为 0, 则不会删除项目。
        * `item1, ..., itemX`: 可选。向数组`添加的新项目`。
    * 返回值
        * Array, 包含被删除项目的新数组，如果有的话。


2. `slice()`: 方法可从已有的数组中返回`选定的元素`
    * 该方法并`不会修改数组`，而是返回一个子数组。
    * `arrayObject.slice(start,end)`
        * `start`: 必需。规定从何处开始选取。
        * `end`: 可选。规定从何处结束选取。
    * 返回值
        * 返回一个`新的数组`，包含从` start 到 end （不包括该元素）`的 arrayObject 中的元素。
    * 案例：
    ```javascript
    [11,22,33,44].slice(1,3);  =>  [22, 33]
    ```

3. `shift()`: 删除数组的第一个元素，并返回第一个元素的值。
    * 该方法会改变数组的长度。
    * 要`删除并返回数组的最后一个元素`，请使用 `pop()` 方法。
    * 案例:
    ```javascript
    const array1 = [1, 2, 3];
    const firstElement = array1.shift();

    console.log(array1);  // Array [2, 3]
    console.log(firstElement); // 1
    ```
4. `forEach()`: 用于遍历数组，无返回值
    * 在forEach使用 `return` 不好用。
    * 例子: 将数组中的每一项翻倍
    ```javascript
    var arr = [1,-2,3,4,-5];
    arr.forEach(function(item,index,array){
        array[index] = item * 2;
    });
    console.log(arr);   // [2,-4,6,8,-10]
    ```
5. `map()`: 用于遍历数组，返回处理之后的新数组
    * 例子: 该方法`与forEach()的功能`类似，只不过`map()具有返回值`, 会返回一个`新的数组`，这样`处理数组后也不会影响到原有数组`。
    ```javascript
    var newArr = arr.map(function(item,index,array){
        return item * 2;
    });
    console.log(newArr);   // [2,-4,6,8,-10]
    ```
6. `flatMap()`: 用于映射函数映射每个元素，然后将结果压缩成一个新数组
    * 例子:  
    ```javascript
    var arr = [1, 2, 3, 4];
    arr.flatMap(x => [x * 2]); // [2, 4, 6, 8]
    ```
    
6. `every()`: 用于判断`数组中的每一项元素是否都满足条件`，返回一个布尔值
    * 例子: 判断数组arr中的元素是否都为正数
    ```javascript
    var arr = [1,-2,3,4,-5];
    var isEvery = arr.every(function(item,index,array){
        return item > 0;
    });
    console.log(isEvery);   // false
    ```
7. `some()`: 用于判断`数组中的是否存在满足条件`的元素，返回一个布尔值
    * 例子: 判断数组arr中是否存在负数元素
    ```javascript
    var arr = [1,-2,3,4,-5];
    var isSome = arr.some(function(item,index,array){
        return item < 0;
    });
    console.log(isSome);   // true
    ```
8. `filter()`: 用于`筛选数组中满足条件的元素，返回一个筛选后的新数组`
    * 例子: 要筛选出数组arr中的所有负数
    ```javascript
    var minus = arr.filter(function(item,index,array){
        return item < 0;
    });
    console.log(minus);   // [-2, -5]
    ```
9. 补充: `forEach()`、`map()`、`every()`、`some()`、`filter()`, 以上五大方法除了传递一个`匿名函数作为参数之外`，还可以传第二个参数，该`参数用于指定匿名函数内的this指向`
    * 例子: 只传一个匿名函数
    ```javascript
    arr.forEach(function(item,index,array){
        console.log(this);  // window
    });
    ```
    * 例子: 传两个参数
    ```javascript
    arr.forEach(function(item,index,array){
        console.log(this);  // [1, -2, 3, 4, -5]
    },arr);
    ```
    * 总结: 
    > 1. forEach()无返回值，map()和filter()返回新数组，every()和some()返回布尔值
    > 2. 匿名函数中this指向默认为window，可通过传第二参数来更改之
    > 3. 五种遍历方法均为ES5方法

4. map，filter，reduce，是三种对集合进行操作的方式
    > 1. 三者都会对集合遍历，不同的是，map和filter给出当前元素，
    > 2. reduce 会给出当前元素和之前元素处理的合集，这个合集可以不只是简单的加减乘除。



## reduce 的用法
``` javascript
array.reduce(function(total, currentValue, currentIndex, arr), initialValue);


total: 必需。初始值, 或者计算结束后的返回值。
currentValue： 必需。当前元素。
currentIndex： 可选。表示当前正在处理的数组元素的索引，若提供 initialValue 的值，则索引为0，否则索引为1。
arr： 可选。当前元素所属的数组对象。
initialValue: 可选。传递给函数的初始值，相当于total的初始值。
```

* `reduce()` 是数组的归并方法, 与`forEach()、map()、filter()`等迭代方法一样都会对数组每一项进行遍历，但是r`educe() 可同时将前面数组项遍历产生的结果与当前遍历项进行运算`，这一点是其他迭代方法无法企及的




1. 使用场景一: 数组求和
```javascript
const arr = [12, 34, 23];
const sum = arr.reduce((total, num) => total + num);

<!-- 设定初始值求和 -->
const arr = [12, 34, 23];
const sum = arr.reduce((total, num) => total + num, 10);  // 以10为初始值求和

<!-- 对象数组求和 -->
var result = [
    { subject: 'math', score: 88 },
    { subject: 'chinese', score: 95 },
    { subject: 'english', score: 80 }
];
const sum = result.reduce((prev, cur) => prev + cur.score, 0); 
const sum = result.reduce((prev, cur) => prev + cur.score, -10);  // 总分扣除10分
```

2. 使用场景二: 数组最大值
```javascript
const arr = [23,123,342,12];
const max = arr.reduce((pre, cur) => pre > cur ? pre : cur)
```

3. 求字符串中字母出现的次数
```javascript
const str = 'sfhjasfjgfasjuwqrqadqeiqsajsdaiwqdaklldflas-cmxzmnha';
const res = str.split('').reduce((accumulator, cur, i, arr) => {
    accumulator[cur] ? accumulator[cur]++ : accumulator[cur] = 1; 
    return accumulator;
}, {});
```

4. 数组转数组
```javascript
<!-- 按照一定的规则转成数组 -->
const arr = [2, 3, 4, 5, 6]; // 每个值的平方
const newarr = arr.reduce((accumulator, cur) => {
    accumulator.push(cur * cur); 
    return accumulator;
}, []);
```

5. 数组转对象
```javascript
const streams = [{name: '技术', id: 1}, {name: '设计', id: 2}];
const obj = streams.reduce((accumulator, cur) => {
    accumulator[cur.id] = cur; 
    return accumulator;
}, {});   
```

6. 扁平一个多维数组
```javascript
var arr = [[1, 2, 8], [3, 4, 9], [5, 6, 10]];
var res = arr.reduce((x, y) => x.concat(y), []);
```

6. 数组去重
```javascript
const arr = [6, 2,3,1,2,3,4,5,1]
const newArr = arr.reduce(function (prev, cur) {
    prev.indexOf(cur) === -1 && prev.push(cur);
    return prev;
},[]);
```







6. 高级用法: 多维的叠加执行操作
   * 各科成绩占比重不一样， 求结果
   ```javascript
    var result = [
        { subject: 'math', score: 88 },
        { subject: 'chinese', score: 95 },
        { subject: 'english', score: 80 }
    ];
    var dis = {
        math: 0.5,
        chinese: 0.3,
        english: 0.2
    };
    var res = result.reduce((accumulator, cur) => {
        return dis[cur.subject] * cur.score + accumulator
    }, 0);
   ```
   * 商品对应不同国家汇率不同，求总价格
    ```javascript
    var prices = [{price: 23}, {price: 45}, {price: 56}];
    var rates = {
        us: '6.5',
        eu: '7.5',
    };
    var initialState = {usTotal:0, euTotal: 0};
    var res = prices.reduce((accumulator, cur1) => Object.keys(rates).reduce((prev2, cur2) => {
    console.log(accumulator, cur1, prev2, cur2);
    accumulator[`${cur2}Total`] += cur1.price * rates[cur2];
    return accumulator;
    }, {}), initialState);

    var manageReducers = function() {
    return function(state, item) {
        return Object.keys(rates).reduce((nextState, key) => {
            state[`${key}Total`] += item.price * rates[key];
            return state;
        }, {});
    }
    };
    var res1= prices.reduce(manageReducers(), initialState);
    ```









## 数组方法归类
1. 添加/移除数组元素
    * arr.push(...items) —— 从尾端添加元素，返回新数组长度。`改变原数组`
    * arr.pop() —— 从尾端提取元素，返回提取的元素。`改变原数组` 
    * arr.shift() —— 从首端提取元素，返回提取的元素。`改变原数组` 
    * arr.unshift(...items) —— 从首端添加元素, 返回新数组长度。`改变原数组`
    * 这里还有其他几种方法:
        * splice: 添加，删除和插入元素。`改变原数组`
            * `arr.splice(start[, deleteCount, elem1, ..., elemN])`
            * 它从索引 start 开始修改 arr：删除 deleteCount 个元素并在当前位置插入 elem1, ..., elemN。`最后返回已被删除元素的数组`。可以将 deleteCount 设置为 0
            * 案例
            ```js
            var arr = ["I", "study", "JavaScript", "right", "now"];
            arr.splice(0, 3, "Let's", "dance"); // 返回: ["I", "study", "JavaScript"]
            arr // ["Let's", "dance", "right", "now"]
            ```
        * slice
            * arr.slice([start], [end])。`不改变原数组`
            * 它会返回一个`新数组`，将所有从索引 start 到 end`（不包括 end）`的数组项复制到一个新的数组。
            * 不带参数地调用它：arr.slice() 会创建一个 arr 的副本。不影响原始数组
            * 案例
            ```js
            var arr = ["t", "e", "s", "t"];
            arr.slice(1,3) // ["e", "s"]
            arr // ["t", "e", "s", "t"]
            ```
        * concat
            * arr.concat 创建一个新数组。`不改变原数组`
2. 遍历：forEach
    * arr.forEach 方法允许为数组的每个元素都运行一个函数。
    ```js
    ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
        console.log(`${item} is at index ${index} in ${array}`);
    });
    ```
3. 在数组中搜索
    * `arr.indexOf(item, from)` 从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。
    ```js
    var arr = ["t", "e", "s", "t"];
    arr.indexOf('e') // 1
    arr.indexOf('e', 2) // -1
    ```
    * `arr.lastIndexOf(item, from)` —— 和上面相同，只是从右向左搜索。
    * `arr.includes(item, from)` —— 从索引 from 开始搜索 item，如果找到则返回 true（译注：如果没找到，则返回 false）。
    * 以上方法都是使用的是严格相等 === 比较。所以如果我们搜索 false，会精确到的确是 false 而不是数字 0。
    * `includes 可以查找 NaN`。indexOf和lastIndexOf不行
4. find 和 findIndex
    * 有一个对象数组。我们如何找到具有特定条件的对象.
    ```js
    let result = arr.find(function(item, index, array) {
        // item 是元素。 index 是它的索引。 array 是数组本身。

        // 如果它返回 true，则搜索停止，并返回 item。
        // 如果没有搜索到，则返回 undefined。
    });
    ```
    * find 方法搜索的是使函数返回 true 的第一个（单个）元素。
    * 案例
    ```js
    let users = [
        {id: 1, name: "John"},
        {id: 2, name: "Pete"},
        {id: 3, name: "Mary"}
    ];
    let user = users.find(item => item.id == 1);
    alert(user.name); // John
    ```
    * `arr.findIndex` 方法（与 arr.find 方法）基本上是一样的，但它`返回找到元素的索引`，而不是元素本身。并且在未找到任何内容时返回 -1。
5. filter
    * filter 返回的是所有匹配元素组成的数组：
    ```js
    let results = arr.filter(function(item, index, array) {
        // 如果 true item 被 push 到 results，迭代继续
        // 如果什么都没找到，则返回空数组
    });
    ```
    * 案例
    ```js
    let users = [
        {id: 1, name: "John"},
        {id: 2, name: "Pete"},
        {id: 3, name: "Mary"}
    ];
    // 返回前两个用户的数组
    let someUsers = users.filter(item => item.id < 3);
    someUsers // [{id: 1, name: "John"},{id: 2, name: "Pete"}]
    ```
6. 转换数组
    * map
        * 它对数组的每个元素都调用函数，并返回结果数组。
        ```js
        let result = arr.map(function(item, index, array) {
            // 返回新值而不是当前元素
        })

        let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
        alert(lengths); // 5,7,6        
        ```
    * sort(fn)
        * arr.sort 方法对数组进行 `原位`（in-place） 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。)
        * 案例
        ```js
        [1, -2, 15, 2, 0, 8].sort(function(a, b) {
            return a - b;
        });
        // [-2, 0, 1, 2, 8, 15]
        ```
    * reverse
        * 方法用于颠倒 arr 中元素的顺序。
        ```js
        let arr = [1, 2, 3, 4, 5];
        arr.reverse();

        alert( arr ); // 5,4,3,2,1
        ```
    * split  
        * 分割数组
        ```js
        let names = 'Bilbo, Gandalf, Nazgul';

        let arr = names.split(', ');

        for (let name of arr) {
            console.log( `A message to ${name}.` ); // A message to Bilbo（和其他名字）
        }
        ```
    * join
        * arr.join(glue) 与 split 相反。它会在它们之间创建一串由 glue 粘合的 arr 项。
        ```js
        let arr = ['Bilbo', 'Gandalf', 'Nazgul'];
        let str = arr.join(';'); // 使用分号 ; 将数组粘合成字符串
        alert( str ); // Bilbo;Gandalf;Nazgul
        ```
    * reduce/reduceRight
        * 当我们需要遍历一个数组时 —— 我们可以使用 forEach，for 或 for..of 和 for in。
        * 当我们需要遍历并返回每个元素的数据时 —— 我们可以使用 map。
        * reduce/reduceRight用于根据数组计算单个值。
        * 语法是：
        ```js
        let value = arr.reduce(function(accumulator, item, index, array) {
            // accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。
            // item —— 当前的数组元素。
            // index —— 当前索引。
            // arr —— 数组本身
        }, [initial]);
        ```
        * arr.reduceRight 和 arr.reduce 方法的功能一样，只是遍历为从右到左。

7. Array.isArray
    * 数组是基于对象的，不构成单独的语言类型。
    * 所以 typeof 不能帮助从数组中区分出普通对象：
    * Array.isArray(value): 用于判断是否为数组
    ```js
    alert(Array.isArray({})); // false

    alert(Array.isArray([])); // true
    ```

8. 大多数方法都支持 “thisArg”
    * 几乎所有调用函数的数组方法 —— 比如 find，filter，map，除了 sort 是一个特例，都接受一个可选的附加参数 thisArg。
    * 以下是这些方法的完整语法：
    ```js
    arr.find(func, thisArg);
    arr.filter(func, thisArg);
    arr.map(func, thisArg);
    // ...
    // thisArg 是可选的最后一个参数

    // thisArg 参数的值在 func 中变为 this。
    ```
    * 案例
    ```js
    let army = {
        minAge: 18,
        maxAge: 27,
        canJoin(user) {
            return user.age >= this.minAge && user.age < this.maxAge;
        }
    };

    let users = [
        {age: 16},
        {age: 20},
        {age: 23},
        {age: 30}
    ];

    // 找到 army.canJoin 返回 true 的 user
    let soldiers = users.filter(army.canJoin, army);

    alert(soldiers.length); // 2
    alert(soldiers[0].age); // 20
    alert(soldiers[1].age); // 23
    ```
## 总结
1. 添加/删除元素：
    * push(...items) —— 向尾端添加元素，
    * pop() —— 从尾端提取一个元素，
    * shift() —— 从首端提取一个元素，
    * unshift(...items) —— 向首端添加元素，
    * splice(pos, deleteCount, ...items) —— 从 pos 开始删除 deleteCount 个元素，并插入 items。
    * slice(start, end) —— 创建一个新数组，将从索引 start 到索引 end（但不包括 end）的元素复制进去。
    * concat(...items) —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 items。如果 items 中的任意一项是一个数组，那么就取其元素。
2. 搜索元素：
    * indexOf/lastIndexOf(item, pos) —— 从索引 pos 开始搜索 item，搜索到则返回该项的索引，否则返回 -1。
    * includes(value) —— 如果数组有 value，则返回 true，否则返回 false。
    * find/filter(func) —— 通过 func 过滤元素，返回使 func 返回 true 的第一个值/所有值。
    * findIndex 和 find 类似，但返回索引而不是值。
3. 遍历元素：
    * forEach(func) —— 对每个元素都调用 func，不返回任何内容。使用break不能中断循环，使用return也不能返回到外层函数。
4. 转换数组：
    * map(func) —— 根据对每个元素调用 func 的结果创建一个新数组。
    * sort(func) —— 对数组进行原位（in-place）排序，然后返回它。
    * reverse() —— 原位（in-place）反转数组，然后返回它。
    * split/join —— 将字符串转换为数组并返回。
    * reduce/reduceRight(func, initial) —— 通过对每个元素调用 func 计算数组上的单个值，并在调用之间传递中间结果。
5. 其他：
    * Array.isArray(arr) 检查 arr 是否是一个数组。
    * filter: 过滤
    * `for in`: 遍历数组=>索引。遍历对象=>key。适合`遍历对象`
    * `for of`: `遍历数组`元素值。不能遍历对象. 
    * for in是遍历键名，for of是遍历键值。
`请注意，sort，reverse 和 splice 方法修改的是数组本身。`
6. 其他几个：
    * arr.some(fn)/arr.every(fn) 检查数组。
        * 与 map 类似，对数组的每个元素调用函数 fn。如果任何/所有结果为 true，则返回 true，否则返回 false。
        * 这两个方法的行为类似于 || 和 && 运算符：如果 fn 返回一个真值，arr.some() 立即返回 true 并停止迭代其余数组项；如果 fn 返回一个假值，arr.every() 立即返回 false 并停止对其余数组项的迭代。
        * 案例: 使用 every 来比较数组：
        ```js
        function arraysEqual(arr1, arr2) {
            return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
        }

        alert(arraysEqual([1, 2], [1, 2])); // true
        ```
    * arr.fill(value, start, end) —— 从索引 start 到 end，用重复的 value 填充数组。
    * arr.flat(depth)/arr.flatMap(fn) 从多维数组创建一个新的扁平数组。
    * Array.of(element0[, element1[, …[, elementN]]]) 基于可变数量的参数创建一个新的 Array 实例，而不需要考虑参数的数量或类型。
    * 参考: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array


















