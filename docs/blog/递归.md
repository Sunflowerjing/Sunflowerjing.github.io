# 递归

* 递归前端经典实现:
    * dom 的 dif
    * koa
* 递归的三大要素:
    * 参考文章：https://www.zhihu.com/question/31412436/answer/683820765
    * 第一要素：明确这个函数想要干什么, 这个函数的功能是什么
    * 第二要素：寻找递归结束条件
        * 需要找出当参数为啥时，递归结束，之后直接把结果返回
        * 这个时候必须能根据这个参数的值，能够直接知道函数的结果是什么
    * 第三要素：找出函数的等价关系式, 不断缩小参数的范围

## 深度优先遍历(DFS)
1. 深度优先遍历方法比较多，最简单就是递归，它的循环写法反而比较难理解 `(看作任务栈)`
2. 该方法是以纵向的维度对dom树进行遍历，从一个dom节点开始，一直遍历其子节点，直到它的所有子节点都被遍历完毕之后在遍历它的兄弟节点。
3. 假设页面的 dom 结构如下:
```javascript
<div id="root">
    <ul>
        <li>
            <a href="">
                <img src="" alt="">
            </a>
        </li>
        <li>
            <span></span>
        </li>
        <li>
        </li>
    </ul>
    <p></p>
    <button></button>
</div>
```
4. 上面的 Dom 对应的图，如下
![深度优先遍历](深度优先遍历.png)
5. js实现该算法代码(递归版本)：
```javascript
function deepFirstSearch(node) {
    const nodeList = [];  
    if (node) {    
        nodeList.push(node);    
        var children = node.children;    
        for (var i = 0; i < children.length; i++) 
        //每次递归的时候将 需要遍历的节点 和 节点所存储的数组传下去
        deepFirstSearch(children[i],nodeList);    
    }    
    return nodeList;  
} 
```
6. js实现该算法代码(非递归版本)：
```javascript
function deepFirstSearch(node) {
    var nodes = [];
    if (node != null) {
        var stack = [];
        stack.push(node);
        while (stack.length != 0) {
        var item = stack.pop();
        nodes.push(item);
        var children = item.children;
        for (var i = children.length - 1; i >= 0; i--)
            stack.push(children[i]);
        }
    }
    return nodes;
}
```
7. 




## 广度优先遍历(BFS)
1. 广度优先算法方法反之，无法使用递归，只能用循环来写，但是容易理解`(看作任务队列)`
2. 该方法是以横向的维度对dom树进行遍历，从该节点的第一个子节点开始，遍历其所有的兄弟节点，再遍历第一个节点的子节点，完成该遍历之后，暂时不深入，开始遍历其兄弟节点的子节点。即如图所示（遍历顺序为红字锁标）：
3. 上面的 Dom 对应的图，如下
![深度优先遍历](广度遍历.png)
4. js实现算法代码（递归版本）：
```javascript 
function breadthFirstSearch(node) {
    var nodes = [];
    var i = 0;
    if (!(node == null)) {
        nodes.push(node);
        breadthFirstSearch(node.nextElementSibling);
        node = nodes[i++];
        breadthFirstSearch(node.firstElementChild);
    }
    return nodes;
}
```
`bug:` 递归版本的BFS由于层级太深，会导致堆栈溢出：`Maximum call stack size exceeded`，但遍历的顺序依旧没有问题，可以在遍历过程中进行操作，不返回遍历数组即可。
6. js实现该算法代码(非递归版本)：
```javascript
function breadthFirstSearch(node) {  
    var nodes = [];  
    if (node != null) {  
        var queue = [];  
        queue.unshift(node);  
        while (queue.length != 0) {  
            var item = queue.shift();  
            nodes.push(item);  
            var children = item.children;  
            for (var i = 0; i < children.length; i++)  
                queue.push(children[i]);  
        }  
    }  
    return nodes;  
}
```