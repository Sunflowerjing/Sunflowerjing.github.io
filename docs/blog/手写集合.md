# 手写集合

* https://juejin.cn/post/6946022649768181774?utm_source=gold_browser_extension
## ⼿写⼀个new操作符
1. new 实现了什么
> (1) 创建了一个**全新的对象。**  
> (2) 这个**对象会被执行[[Prototype]]**（也就是__proto__）链接。  
> (3) 生成的新对象会绑定到**函数调用的this。**  
> (4) 通过new创建的每个**对象将最终被[[Prototype]]链接到这个函数的prototype对象上。**  
> (5) 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会**自动返回这个新的对象。**

2. new 的实现过程:
```javascript
function objectFactory() {

    var obj = new Object(),

    Constructor = [].shift.call(arguments); 

    obj.__proto__ = Constructor.prototype;

    var ret = Constructor.apply(obj, arguments);

    return typeof ret === 'object' ? ret : obj;

};
```







## 原型链继承
```javascript
var Car = function(color){
    // constructor == Car 构造函数和初始化这个类就是一个东西了
    this.color = color;
}
Car.prototype.sail = function(){
	console.log(this.color+'卖了红色的车');
}
var BMW = function (color){
	Car.call(this, color);
}
// 按引用传递
// 1.拿到父类原型链上的方法
// 2.不能让构造函数执行2次
// 3.引用的原型链不能是按址引用
// 4.修正子类的constructor 
BMW.prototype = Object.create(Car.prototype);
BMW.prototype.constructor = BMW;

var m = new BMW('red');
console.log(m);

```


## ⼿写⼀个JSON.stringify和JSON.parse

## ⼿写一个 call 或 apply
1. 实现 apply, 不能用 call
```javascript
Function.prototype.myApply = function (context) {
    var context = context || window
    context.fn = this
    var result
    // 需要判断是否存储第二个参数 
    // 如果存在，就将第二个参数展开 
    if (arguments[1]) {
      result = context.fn(...arguments[1])
    } else {
      result = context.fn()
    }
    delete context.fn
    return result
}
```

2.  实现 call
```javascript
Function.prototype.myCall = function(context){
    var context = context || window;
    context.fn = this;
    var args = [...arguments].slice(1);
    var result = context.fn(...args);
    delete context.fn
    return result;
}

var obj = {name:'jing'}
function hello(){
    return this.name 
}
hello.myApply(obj);
```

## ⼿写一个Function.bind
```javascript
Function.prototype.bind = function(obj, ...args){
    if(typeof obj !== 'function'){
        throw new TypeError('被绑定的对象需要是函数')
    }
    var fn1 = this;  // 是否是一个函数的实例
    return function fn2(...args2){
        return fn1.apply(obj, args.concat(args2))
    }
}
```

## ⼿写防抖(Debouncing)和节流(Throttling)
1. `防抖`动和`节流`本质是不一样的。
    * `防抖`动是将多次执行变为`最后一次执行`, 按钮提交场景、搜索框联想场景
    * `节流`是将多次执行变成`每隔一段时间执行`, 拖拽场景、缩放场景
2. `函数防抖`: 在事件被触发n秒后再执行回调,如果在这n秒内又被触发,则重新计时;典型的案例就是输入搜索:输入结束后n秒才进行搜索请求,n秒内又输入的内容,就重新计时。
```javascript
function debounce(fn, delay){
    var timer = null;
    return function(){
        const that = this;
        const args = arguments;
        clearTimeout(timer)
        timer = setTimeout(function(){
                fn.apply(that, args)
            }, delay);
        
    }
}
function handle(){
     console.log('123')
}
            
// 滚动事件
document.getElementById('s').addEventListener('click', debounce(handle, 1000))
```

3. `函数节流`：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。
    * 使用时间戳实现
        ```javascript
        function throttle(func, wait) {
            let context, args;
            let previous = 0;
            return function () {
                let now = +new Date();
                context = this;
                args = arguments;
                if (now - previous > wait) {
                    func.apply(context, args);
                    previous = now;
                }
            }
        }
        ```
    * 使用定时器实现
        ```javascript
        function throttle(func, wait) {
            let timeout;
            return function () {
                const context = this;
                const args = arguments;
                if (!timeout) {
                    timeout = setTimeout(function () {
                        timeout = null;
                        func.apply(context, args)
                    }, wait)
                }
            }
        }
        ```





## ⼿写一个JS深拷贝(由浅入深多种解法)

## ⼿写⼀个instanceOf原理

## ⼿写⼀个map和reduce

## 手写实现拖拽

## 使用setTimeout模拟setInterval

## ⼿写实现Object.create的基本原理



## 实现Promise
```javascript
// promise 的三种状态
const PENDING = 'PENDING';
const FULFILLED = 'FULFILLED';
const REJECTED = 'REJECTED';
class MyPromise {
    constructor(fn){
        this.state = PENDING;
        this.value = undefined;
        this.resolvedCallbacks = []; 
        const resolve = (val) => {
            setTimeout(() => {
                if(this.state === PENDING) {
                    this.state = FULFILLED;
                    this.value = val;
                    // 执行所有的 then 方法
                    this.resolvedCallbacks.map(fn => fn());  // 此处不用传参数了
                }
            });
        };
        const reject = (val) => {
            this.state = REJECTED;
            this.value = val;
        };
        fn(resolve, reject);
    }
    then(onFulfilled) {
        if(this.state === PENDING){
            return new MyPromise((resolve, reject) => {  // return 一个 promise 才支持链式调用
                this.resolvedCallbacks.push(() =>{
                    const x = onFulfilled(this.value);
                    resolve(x);
                });
            })
        }
    }
}
```


## 实现Promise.all
```javascript
var promiseAll = (fn) => {
    return new Promise((resolve, reject) => {
        let successCount = 0;
        let resultArr = [];
        //注意: 循环 i 的问题, 不能用 var。用 let 或者 立即执行函数
        for(let i=0; i<fn.length; i++){ 
            // 1. let
            fn[i].then((data) => {
                successCount++;
                resultArr[i] = data;
                if(successCount == fn.length){
                    resolve(resultArr)
                }
            }).catch(err => {
                reject(err)
            })
            // 2. 立即执行函数
            (function(i){ .......上面代码 })()
        }
    })
} 

var p1 = new Promise((resolve,reject) => {
    setTimeout(() => {
        resolve('p1111')
    }, 3000)
})

var p2 = new Promise((resolve,reject) => {
    setTimeout(() => {
        resolve('p22222')
    }, 2000)
})

var p3 = new Promise((resolve,reject) => {
    setTimeout(() => {
        resolve('p3333')
    }, 1000)
})

promiseAll([p1, p2, p3]).then((res,err) => {
    console.log('正确结果', res);
}).catch(err => {
    console.log(' 错误结果', err);
})
```


## 多维数组转一维数组
```js
var newArr = (arr) => arr.reduce((pre,cur) => {
        if(Array.isArray(cur)){
            return pre.concat(newArr(cur))
        }
        return pre.concat(cur)
}, [])
```

## 实现 polyfill




## setTimeout和setInterval的延迟如何解决
```javascript
function manualTimeout(callback, time) {
  var target = performance.now() + time;
  var recall = function () {
    if (performance.now() > target) {
      callback();
    } else {
      setTimeout(recall, 0);
    }
  };
  recall();
}
```
