# 基本概念

1. `prototype 原型`: js 上的方法都是定义到, prototype上。
2. `原型链`
    * `构造函数`里的属性的 `优先级`比原型链的要`高`
    * 面向对象编程的时候, JS 没有类的概念。可以用函数替代
    * constructor实际就是对应的那个函数本身
    * prototype是按照引用传递的  Object.create创建原型链的副本
3. `闭包`：`外部函数可以访问内部函数的变量，并且内部函数返回一个函数出去`。闭包可以保护内部的变量  闭包造成内存泄露==null。
4. 改变`this`的方法 `call apply bind`。
5. 函数提升 变量提升 `函数提升级别比变量高`。
6. `对象 数组 按引用类型传递`。



## JS面向对象

1.继承： `一个类获取另一个或者多个类的属性或者方法`。继承可以使得`子类具有父类的各种方法和属性`。以免重复输出很多代码。
```
var Car = function(color){
    // constructor == Car 构造函数和初始化这个类就是一个东西了
    this.color = color;
}
Car.prototype.sail = function(){
	console.log(this.color+'卖了红色的车');
}
var BMW = function (color){
	Car.call(this, color);
}
// 按引用传递
// 1.拿到父类原型链上的方法
// 2.不能让构造函数执行2次
// 3.引用的原型链不能是按址引用
// 4.修正子类的constructor 
BMW.prototype = Object.create(Car.prototype);
BMW.prototype.constructor = BMW;

var m = new BMW('red');
console.log(m);
```

## new 实现了什么
> 1.创建了一个**全新的对象。**  
>2.这个**对象会被执行[[Prototype]]**（也就是__proto__）链接。  
> 3.生成的新对象会绑定到**函数调用的this。**  
> 4.通过new创建的每个**对象将最终被[[Prototype]]链接到这个函数的prototype对象上。**  
>5.如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会**自动返回这个新的对象。**



## bind、apply和 call 的实现
1. bind 实现
```
Function.prototype.bind = function(obj, ...args){
  if(typeof this !== 'function'){
        throw new TypeError('被绑定的对象需要是函数')
    }
  var fn1 = this;  // 是否是一个函数的实例
  return function fn2(...args2){
     return fn1.apply(obj, args.concat(args2))
  }
}

function fn1(a, b){
   console.log(arguments, this)
}
var fn2 = fn1.bind({a:1}, 1,2);
fn2(3,4)
```

2. call 的实现
```
Function.prototype.myCall = function (context) {
    var context = context || window;
    context.fn = this;
    var args = [...arguments].slice(1);
    var result = context.fn(...args);
    delete context.fn
    return result
}     
var o = {
    name:'小明'
}   

function test(){
    console.log('执行了', this.name);
}

test.myCall(o)
```

3. apply 的实现
```
Function.prototype.myApply = function (context) {
       var context = context || window
       context.fn = this
       var result
       // 需要判断是否存储第二个参数 
       // 如果存在，就将第二个参数展开 
       if (arguments[1]) {
         result = context.fn(...arguments[1])
       } else {
         result = context.fn()
       }
       delete context.fn
       return result
}
```
 

## 防抖和节流
**防抖**动和**节流**本质是不一样的。`防抖动是将多次执行变为最后一次执行`，`节流是将多次执行变成每隔一段时间执行`。

1.**函数防抖**: 当持续触发事件时，`一定时间段内没有再触发事件，事件处理函数才会执行一次`，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
![image.png](https://upload-images.jianshu.io/upload_images/11405974-f0423b9c285fe7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
function debounce(fn, wait){
      var timeout = null;
      return function(){
           if(timeout!==null){
                clearTimeout(timeout); 
           }
           timeout = setTimeout(fn, wait);
      }
}
function handle(){
     console.log('123')
}
            
// 滚动事件
document.getElementById('s').addEventListener('click', debounce(handle, 1000));
```

2. **函数节流**：`当持续触发事件时，保证一定时间段内只调用一次事件处理函数。`
![image.png](https://upload-images.jianshu.io/upload_images/11405974-0d7d6c9d3326aa2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
function throttle(fn, delay){
       var timer = null;
       return function(){
              var self = this;
              var args = arguments;
              if (!timer) {
                   timer = setTimeout(function() {
                         fn.apply(self, args);
                         timer = null;
                   }, delay);
              }
       }
}
function handle(){
    console.log('123')
}
            
// 滚动事件
document.getElementById('s').addEventListener('click', throttle(handle, 2000));
```

**总结**:
**函数防抖**：`将几次操作合并为一此操作进行`。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

**函数节流**：`使得一定时间内只触发一次函数`。原理是通过判断是否到达一定时间来触发函数。

**区别**： `函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数`，而`函数防抖只是在最后一次事件后才触发一次函数`。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。






