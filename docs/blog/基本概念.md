# 基本概念

1. `prototype 原型`: js 上的方法都是定义到, prototype上。
2. `原型链`
    * `构造函数`里的属性的 `优先级`比原型链的要`高`
    * 面向对象编程的时候, JS 没有类的概念。可以用函数替代
    * constructor实际就是对应的那个函数本身
    * prototype是按照引用传递的  Object.create创建原型链的副本
3. `闭包`：`外部函数可以访问内部函数的变量，并且内部函数返回一个函数出去`。闭包可以保护内部的变量  闭包造成内存泄露==null。
4. 改变`this`的方法 `call apply bind`。
5. 函数提升 变量提升 `函数提升级别比变量高`。
6. `对象 数组 按引用类型传递`。


## 重要图片理解
![重要图片理解](原型链.jpg)

## JavaScript 控制台功能
1. `console.log()`: 将消息输出到控制台。
2. `console.info()`: log 和 info 之间并没有真正的区别。
3. `console.warn()`: 将`警告消息打印到控制台`。该消息在控制台中带有黄色背景, 并带有警告图标。
4. `console.error()`: 将`错误信息输出到控制台`。在控制台中具有红色背景，并带有带有白色 “x” 错误图标的红色圆圈。
5. `console.table()`:  接受一些能够`以表格形式展示的数据`并输出。
6. `console.assert()`: 是一种将`未满足你确定条件的消息打印到控制台`的方法。该函数有两个参数: `要求值的表达式和应显示的错误消息`。
```
const obj = { restaurantName: 'Pizza Planet' };
console.assert(obj.restaurantName === 'Pizza Palace', 'The name of the restaurant is not "Pizza Palace"');
// ❌ Assertion Failed; 'The name of the restaurant is not "Pizza Palace"'

这可能是另一种非常好的调试程序的方法。仅当断言失败时才会显示该消息，因此如果未显示任何消息，则可以假定表达式正评估正确。
```
7. `console.group() 和 console.groupEnd()`:  是可以将许多 `console.log 逻辑分组`的方式。然后，你可以在需要时`通过折叠组`以将其隐藏。
```
console.group();
console.log({ restaurantName: 'Pizza Palace' });
console.groupEnd();
```
 


## JS面向对象

1.继承： `一个类获取另一个或者多个类的属性或者方法`。继承可以使得`子类具有父类的各种方法和属性`。以免重复输出很多代码。
```
var Car = function(color){
    // constructor == Car 构造函数和初始化这个类就是一个东西了
    this.color = color;
}
Car.prototype.sail = function(){
	console.log(this.color+'卖了红色的车');
}
var BMW = function (color){
	Car.call(this, color);
}
// 按引用传递
// 1.拿到父类原型链上的方法
// 2.不能让构造函数执行2次
// 3.引用的原型链不能是按址引用
// 4.修正子类的constructor 
BMW.prototype = Object.create(Car.prototype);
BMW.prototype.constructor = BMW;

var m = new BMW('red');
console.log(m);
```




## bind、apply和 call 的实现
1. bind 实现
```
Function.prototype.bind = function(obj, ...args){
  if(typeof this !== 'function'){
        throw new TypeError('被绑定的对象需要是函数')
    }
  var fn1 = this;  // 是否是一个函数的实例
  return function fn2(...args2){
     return fn1.apply(obj, args.concat(args2))
  }
}

function fn1(a, b){
   console.log(arguments, this)
}
var fn2 = fn1.bind({a:1}, 1,2);
fn2(3,4)
```

2. call 的实现
```
Function.prototype.myCall = function (context) {
    var context = context || window;
    context.fn = this;
    var args = [...arguments].slice(1);
    var result = context.fn(...args);
    delete context.fn
    return result
}     
var o = {
    name:'小明'
}   

function test(){
    console.log('执行了', this.name);
}

test.myCall(o)
```

3. apply 的实现
```
Function.prototype.myApply = function (context) {
       var context = context || window
       context.fn = this
       var result
       // 需要判断是否存储第二个参数 
       // 如果存在，就将第二个参数展开 
       if (arguments[1]) {
         result = context.fn(...arguments[1])
       } else {
         result = context.fn()
       }
       delete context.fn
       return result
}
```
 

## 防抖和节流
**防抖**动和**节流**本质是不一样的。`防抖动是将多次执行变为最后一次执行`，`节流是将多次执行变成每隔一段时间执行`。

1.**函数防抖**: 当持续触发事件时，`一定时间段内没有再触发事件，事件处理函数才会执行一次`，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
![image.png](https://upload-images.jianshu.io/upload_images/11405974-f0423b9c285fe7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
function debounce(fn, wait){
      var timeout = null;
      return function(){
           if(timeout!==null){
                clearTimeout(timeout); 
           }
           timeout = setTimeout(fn, wait);
      }
}
function handle(){
     console.log('123')
}
            
// 滚动事件
document.getElementById('s').addEventListener('click', debounce(handle, 1000));
```

2. **函数节流**：`当持续触发事件时，保证一定时间段内只调用一次事件处理函数。`
![image.png](https://upload-images.jianshu.io/upload_images/11405974-0d7d6c9d3326aa2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
function throttle(fn, delay){
       var timer = null;
       return function(){
              var self = this;
              var args = arguments;
              if (!timer) {
                   timer = setTimeout(function() {
                         fn.apply(self, args);
                         timer = null;
                   }, delay);
              }
       }
}
function handle(){
    console.log('123')
}
            
// 滚动事件
document.getElementById('s').addEventListener('click', throttle(handle, 2000));
```

**总结**:
**函数防抖**：`将几次操作合并为一此操作进行`。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

**函数节流**：`使得一定时间内只触发一次函数`。原理是通过判断是否到达一定时间来触发函数。

**区别**： `函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数`，而`函数防抖只是在最后一次事件后才触发一次函数`。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。






