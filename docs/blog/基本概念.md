# 基本概念

1. `prototype 原型`: js 上的方法都是定义到, prototype上。
2. `原型链`
    * `构造函数`里的属性的 `优先级`比原型链的要`高`
    * 面向对象编程的时候, JS 没有类的概念。可以用函数替代
    * constructor实际就是对应的那个函数本身
    * prototype是按照引用传递的  Object.create创建原型链的副本
3. `基本类型和引用类型`
    * 基本类型:
        * null
            * Null 类型也只有一个值，就是 null，它的语义表示空值
            * null 是 JavaScript 关键字
            * 常见问题：null 和 undefined 的区别？
            ```JS
            // null表示"没有对象"，即该处不应该有值。典型用法是：
            1. 作为函数的参数，表示该函数的参数不是对象
            2. 作为对象原型链的终点
            Object.getPrototypeOf(Object.prototype) // null

            // undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：
            （1）变量被声明了，但没有赋值时，就等于undefined。
            （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
            （3）对象没有赋值的属性，该属性的值为undefined。
            （4）函数没有返回值时，默认返回undefined。
            //变量被声明了，但没有赋值时，就等于undefined。
            var i;
            i // undefined 

            //调用函数时，应该提供的参数没有提供，该参数等于undefined。
            function f(x){console.log(x)}
            f() // undefined

            //对象没有赋值的属性，该属性的值为undefined。
            var  o = new Object();
            o.p // undefined

            //函数没有返回值时，默认返回undefined。
            var x = f();
            x // undefined
            ```    
        * undefined
            * Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。
            * 任何变量在赋值前是 Undefined 类型、值为 undefined
            * undefined 是一个变量，而并非是一个关键字
            ```js
            // 为什么有的编程规范要求用 void 0 代替 undefined？
            因为 JavaScript 的代码 undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，建议使用 void 0 来获取 undefined 值，void 后面随便跟上一个便组成表达式，返回就是 undefined

            let a
            a === undefined  //true

            a      //undefined
            void 0 //undefined      void 后面随便跟上一个组成表达式返回就是 undefined

            a === void 0  //true
            ```
        * boolean
        * number
        * string
        * symbol(ES6): 表示独一无二的值
        * BigInt: 目的是比Number数据类型支持`范围更大的整数值`
    * 引用类型(Object):
        * Array
        * Function
        * Date
        * RegExp
    * 基本类型与引用类型区别
        * 存放位置: 基本类型值在内存中占据固定大小，直接存储在`栈内存`中的数据。引用类型`在栈中存储了指针`，这个指针指向堆内存中的地址，真实的`数据存放在堆内存`里。
        * 值的可变性：基本数据类型值不可变，javascript中的原始值（undefined、null、布尔值、数字和字符串）是不可更改的。引用类型是可以直接改变其值的
        * 比较：： 基本类型的比较是`值的比较`，只要它们的值相等就认为他们是相等的。引用数据类型的比较是`引用的比较`，看其的引用是否指向同一个对象
    * typeof 和 instanceof
        * typeof: `typeof Symbol()`。
            * typeof 对于基本类型，除了 null 都可以显示正确的类型，对于 null 来说，虽然它是基本类型，但是会显示 object
            * typeof 对于对象，除了函数都会显示 object
            * typeof的安全防范机制: `检查 DEBUG 变量是否已被声明`
            ```js
            if (DEBUG) {
            console.log('Debugging is starting');
            }
            // 报错 ReferenceError 错误

            if (typeof DEBUG !== 'undefined') {
            console.log('Debugging is starting');
            }
            ```
        * instanceof: `obj instanceof Object`
        * 获得一个变量的正确类型:  `Object.prototype.toString.call(xx)`
 
4. 改变`this`的方法 `call apply bind`。
5. 函数提升 变量提升 `函数提升级别比变量高`。
6. `对象 数组 按引用类型传递`。
7. `js 执行顺序`：变量提升（编译过程中）。先编译在执行。当变量和函数名一样，函数优先级更高一些
8. 谁调用我，this 就执行谁。
9. `use strict`  严格模式  this 为 `undefined`
10. `闭包`: return 出去的函数，里面的变量还在指向外层函数，没有被 gc 回收
11. `IFE`: 立即执行函数，改变了作用域    
12. 挂载类上的都是`静态方法`。挂载原型上的方法都是`动态方法`。  
13. `Object.entries` 来实现继承静态属性
14. 闭包实现缓存
    ```javascript
    const systemType = (function(){
        let ret = void 0;
        return function(){
            if (typeof ret === 'string') {   
                return ret;
            }
            const ua = navigator.userAgent;
            const isAndroid = /(Android|Adr)/i.test(ua); //android终端
            const isiOS = /(iPhone|iPad|iPod|iOS)/i.test(ua); //ios终端
            if(isAndroid){
                return ret = 'Android'
            } else if(isiOS){
                return ret = 'iOS'
            }
                return ret = '';
            }
    })();
    ```



## 重要图片理解
![重要图片理解](原型链.jpg)

## JavaScript 控制台功能
1. `console.log()`: 将消息输出到控制台。
2. `console.info()`: log 和 info 之间并没有真正的区别。
3. `console.warn()`: 将`警告消息打印到控制台`。该消息在控制台中带有黄色背景, 并带有警告图标。
4. `console.error()`: 将`错误信息输出到控制台`。在控制台中具有红色背景，并带有带有白色 “x” 错误图标的红色圆圈。
5. `console.table()`:  接受一些能够`以表格形式展示的数据`并输出。
6. `console.assert()`: 是一种将`未满足你确定条件的消息打印到控制台`的方法。该函数有两个参数: `要求值的表达式和应显示的错误消息`。
```
const obj = { restaurantName: 'Pizza Planet' };
console.assert(obj.restaurantName === 'Pizza Palace', 'The name of the restaurant is not "Pizza Palace"');
// ❌ Assertion Failed; 'The name of the restaurant is not "Pizza Palace"'

这可能是另一种非常好的调试程序的方法。仅当断言失败时才会显示该消息，因此如果未显示任何消息，则可以假定表达式正评估正确。
```
7. `console.group() 和 console.groupEnd()`:  是可以将许多 `console.log 逻辑分组`的方式。然后，你可以在需要时`通过折叠组`以将其隐藏。
```
console.group();
console.log({ restaurantName: 'Pizza Palace' });
console.groupEnd();
```
 

 ## this 总结
1. 如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window（除去严格模式外）。
2. 如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。
3. 如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，例子3可以证明。
```javascript
// 第一条
 function a(){
    var name= "harden";
    console.log(this.name); //undefined
    console.log(this); //Window
}
a();

// 第二条
var a = {
    name:'harden',
    fn:function() {
        console.log(this.name);//harden
        console.log(this);//指向a(可以自己跑一下)
    }
}
a.fn()

// 第三条
var a = {
    name:'harden',
    b:{
        name:'james',
        fn:function() {
            console.log(this.name);//james
            console.log(this);//指向b
        }
    }
}
a.b.fn()
```


## JS面向对象

1.继承： `一个类获取另一个或者多个类的属性或者方法`。继承可以使得`子类具有父类的各种方法和属性`。以免重复输出很多代码。
```javascript
var Car = function(color){
    // constructor == Car 构造函数和初始化这个类就是一个东西了
    this.color = color;
}
Car.prototype.sail = function(){
	console.log(this.color+'卖了红色的车');
}
var BMW = function (color){
	Car.call(this, color);
}
// 按引用传递
// 1.拿到父类原型链上的方法
// 2.不能让构造函数执行2次
// 3.引用的原型链不能是按址引用
// 4.修正子类的constructor 
BMW.prototype = Object.create(Car.prototype);
BMW.prototype.constructor = BMW;

var m = new BMW('red');
console.log(m);
```




## bind、apply和 call 的实现
1. bind 实现
```javascript
Function.prototype.bind = function(obj, ...args){
  if(typeof obj !== 'function'){
        throw new TypeError('被绑定的对象需要是函数')
    }
  var fn1 = this;  // 是否是一个函数的实例
  return function fn2(...args2){
     return fn1.apply(obj, args.concat(args2))
  }
}

function fn1(a, b){
   console.log(arguments, this)
}
var fn2 = fn1.bind({a:1}, 1,2);
fn2(3,4)
```

2. call 的实现
```javascript
Function.prototype.myCall = function (context) {
    var context = context || window;
    context.fn = this;
    var args = [...arguments].slice(1);
    var result = context.fn(...args);
    delete context.fn
    return result
}     
var o = {
    name:'小明'
}   

function test(){
    console.log('执行了', this.name);
}

test.myCall(o)
```

3. apply 的实现
```javascript
Function.prototype.myApply = function (context) {
       var context = context || window
       context.fn = this
       var result
       // 需要判断是否存储第二个参数 
       // 如果存在，就将第二个参数展开 
       if (arguments[1]) {
         result = context.fn(...arguments[1])
       } else {
         result = context.fn()
       }
       delete context.fn
       return result
}
```
 

## 防抖和节流
**防抖**动和**节流**本质是不一样的。`防抖动是将多次执行变为最后一次执行`，`节流是将多次执行变成每隔一段时间执行`。

1.**函数防抖**: 当持续触发事件时，`一定时间段内没有再触发事件，事件处理函数才会执行一次`，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
![防抖和节流](https://upload-images.jianshu.io/upload_images/11405974-f0423b9c285fe7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```javascript
function debounce(fn, wait){
      var timeout = null;
      return function(){
           if(timeout!==null){
                clearTimeout(timeout); 
           }
           timeout = setTimeout(fn, wait);
      }
}
function handle(){
     console.log('123')
}
            
// 滚动事件
document.getElementById('s').addEventListener('click', debounce(handle, 1000));
```

2. **函数节流**：`当持续触发事件时，保证一定时间段内只调用一次事件处理函数。`
![image.png](https://upload-images.jianshu.io/upload_images/11405974-0d7d6c9d3326aa2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```javascript   
function throttle(fn, delay){
       var timer = null;
       return function(){
              var self = this;
              var args = arguments;
              if (!timer) {
                   timer = setTimeout(function() {
                         fn.apply(self, args);
                         timer = null;
                   }, delay);
              }
       }
}
function handle(){
    console.log('123')
}
            
// 滚动事件
document.getElementById('s').addEventListener('click', throttle(handle, 2000));
```

**总结**:
**函数防抖**：`将几次操作合并为一此操作进行`。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

**函数节流**：`使得一定时间内只触发一次函数`。原理是通过判断是否到达一定时间来触发函数。

**区别**： `函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数`，而`函数防抖只是在最后一次事件后才触发一次函数`。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。






