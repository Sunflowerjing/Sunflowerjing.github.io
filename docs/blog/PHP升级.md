# PHP升级

## 面向对象介绍
* `软件危机`是指落后的软件生成方式无法满足迅速增长的计算机软件需求。
* 软件工程学: 分为`结构化方法`和`面向对象`。结构化方法(按软件周期分为三个阶段: `分析`、`设计`和`编程`)。
* `OOP: 面向对象编程`。其编程的代码更简洁、更易于维护,并具有更强的可重用性。
* OOP 达到了软件工程的三个目标: `重用性`、`灵活性`、`扩展性`。
* OOP 面向对象编程的三个特点: `封装`、`多态`、`继承`。

## 类 和 对象
* 类: 大的范围。例如: 人类。
* 对象: 具体到某一个实体。例如: 张三。
* `类`是内置的构造函数，`对象`就是实例。`对象是，构造函数 new 出来的`(JavaScript)。
* 面向对象的三个主要特性：
    * 行为: 方法
    * 状态: 属性
    * 标识: 姓名。例如: var s = new Object。其中 s 就是一个标识。

## PHP类的格式
1. 简单的格式
```
[修饰符] class 类名 {  // 使用 class 关键字加空格后加类名
    [成员属性] // 也叫成员变量
    [成员方法] // 也叫成员函数
} 
```
2. 完整的格式
```
[修饰符] class 类名 [extends 父类][implements 接口1[, 接口2...]] {
    [成员属性] // 也叫成员变量
    [成员方法] // 也叫成员函数
} 
```
3. 成员属性
* 格式: `修饰符 $变量名[=默认值]; `  // 例如: public $name='小明';
* 注意: 成员属性`不可以`是`带运算符的表达式`、`变量`、`方法或函数`调用。
* 错误格式:
```
public $var1 = 1+2;
public $var2 = self::myStaticMethod();
public $var3 = $myVar;
```
* 正确定义方式:
```
public $var1 = 100; // 普通数值 (4个标量: 整数、浮点数、布尔、字符串)
public $var2 = myConstant;  // 常量
public $var3 = self::myStaticMethod;  // 静态属性
public $var4 = array(true, false);  //  数组
```
4. 成员方法
* 格式:
```
[修饰符] function 方法名(参数..){
    [方法体]
    [return 返回值]
}
```
* 例子:
```
public function say(){ // 人可以说话的方法哦
    echo '人在说话'; // 方法体
}
```
5. 实例化对象
* 使用 new 关键字来生成一个对象。
* `$对象名称 = new 类名称();`
* `$对象名称 = new 类名称([参数列表]);`

6. 对象中成员的访问
* `$引用名 = new 类名(构造参数);`
* `$引用名->成员属性 = 赋值;   //对象属性赋值`
* `echo $引用名->成员属性;    //输出对象的属性`
* `$引用名->成员方法(参数);   //调用对象的方法`  

7. 特殊对象的引用 $this
```
<?php
    class Person{
        public $age;
        public function say($word){
            echo '我说了什么? '.$word;
        }
        public function info(){
            $this->say('哈哈哈');  // 需要注意的是,调用成员方法或者属性的时候不要用$。
            return $this->age;
        }
    }
    $o = new Person();
    $o->age = 20;
    // $o->say();
    $result = $o->info();
    echo '<br />';
    echo $result;
?>
```
## 构造方法和析构方法
* 两个下划线 `__`, 表示私有的方法。
1. 构造方法

* 构造方法: 在类声明的时候被执行。`即: 当这个类 new 的时候自动执行`
* 构造方法的语法格式:
```
[修饰符] function __construct([参数]){
    程序体
}    
```

2. 析构方法
* 析构方法: 下面在没有此类方法调用的时候，就会执行析构方法。`即: 对象被销毁的时候执行, 没有代码在去运行了`
* 用途: 可以进行资源的释放操作,例如: 数据库的关闭。
* 析构方法的语法格式:
```
[修饰符] function __destruct([参数]){
    程序体
}   
```

## PHP 面向对象封装性

1. 设置私有成员与私有成员的访问。
    * 封装的修饰符: `public(公有的,默认)`、`private(私有的)`、`protected(受保护的)`
    * 设置私有成员: 只要在声明成员属性或成员方法时, 使用 private 关键字修饰就是实现了对成员的私有封装。
    * 访问私有成员: `私有的成员方法,不能在类的外部直接访问`。只能在对象的内部方法中使用`$this`访问。
2. 以下几个魔术方法, 只针对`private、protected`修饰的变量生效。(__两个下划线是私有的)
    * 魔术方法 __set(); `当外面的元素，对类里面的元素进行设置值的时候，会自动调用。`
    * 魔术方法 __get();`取这个元素的时候会自动调用`
    * 魔术方法 __isset();  `对类里面成员属性进行判断的时候调用`。属性是public修饰的话,为 true。属性是private、protected修饰的话,为 false。
    * 魔术方法 __unset();  `从类外释放属性的时候进行调用`
    ```
    <?php
        class Person{
            private $is='我存在啊';
            private $name = 'jingjing';
            private $age = 28;
            protected $many = 200;
            
            private function getAge(){
                return $this->age;
            }

            // 被保护的成员方法，不能在类的外部直接被访问
            protected function getMany(){
                return $this->many;
            }

            public function user(){
                echo $this->$is.'===='.$this->name.'======'.$this->getAge().'====='.$this->getMany();
            }

            public function __set($key,$value){
                // 魔术方法的set  只针对 protected private 
                echo $key.'-------'.$value.'<br/>';
                if($key ==='name' && $value === '小红'){
                    echo '要修改了<br/>';
                    $this->name='小红';
                }
            }
            public function __get($key){
                if($key === 'age'){
                    return '不想告诉你我的年龄==='.$this->age.'<br/>';
                }
            }
            public function __isset($key){
                if($key === 'is'){
                    return false;
                }
            }
            public function __unset($key){
                echo '<br/> 调用__unset()方法';
                if($key === 'is'){
                    unset($this->is);
                }
            }
        }
        $p = new Person();
        $p->name='小红';   // 调用__set()方法
        echo $p->age;     // 调用__get()方法
        var_dump(isset($p->is)); // 调用__isset()方法
        unset($p->is);  // 调用__unset()方法
        echo $p->is;  // 没有输出的原因是,私有属性。可以调用__get()方法
        $p->user();  // $this->$is报错。别的属性正常输出。
    ?>
    ```
    * 正常情况下, 在外面调用私有属性、私有方法会报错。
    * 若要修改私有属性，则调用`__set()`方法。
    * 若外部输出私有属性，则调用`__get()`方法。
3. `封装性`: 就是把对象中的`成员属性`和`成员方法`加上访问修饰符,使其尽可能`隐藏对象的内部细节`,以达到对成员的`访问控制(切记不是拒绝访问)`。
4. `继承性`: PHP只支持单继承, `不允许多重继承`(既: 一个子类只能有一个父亲类)。`可以有多层继承`(即:  一个类可以继承某一个类的子类)。
5. `多态性`: 是指在`父类中定义的属性或行`为`被子类继承后`, 可以具有不同的数据类型或表现出不同的行为。这使得同一属性或行为在父类及其`各个子类中具有不同的含义`。
6. `子类中重载父类方法`: 
    * 在子类里面允许重写(覆盖)父类中的方法
    * 在子类中, 使用 parent 访问父类中被覆盖的属性和方法
    * PHP实现重载的办法: `parent::construct()` `parent::fun()`
7. `抽象方法`: 当类中有一个方法, 没有方法体, 也就是没有花括号, 直接分号结束, 像这样的方法我们叫做抽象方法, 必须使用关键字abstract定义。例如: `public abstract function fun()`。
8. `抽象类`: 包含`抽象方法`的类必须是`抽象类`, 也要使用关键字`abstract`加以声明。(即使用关键字`abstract`修饰的类为抽象类)
    * 抽象类的特点: 不能实例化, 也就是不能new成对象。必须由一个子类去继承, 并且把抽象类的抽象方法都实现了
    * 若想使用抽象类, 就必须定义一个类去继承这个抽象类, 并定义覆盖父类的抽象方法(实现抽象方法)。
    * 抽象类不一定非得含有抽象方法。抽象类可以存在普通方法。
    * 例如: `abstract class Person{}`。
9. `接口`: PHP不支持多重继承, 也就是说`每个类只能继承一个父类`。为了解决这个问题, 接口的思想是`指定一个实现该接口的类必须实现的一系列函数`。
    * 定义格式: 
    ```
    1. 接口声明的关键字是interface
    2. 接口可以声明常量也可以抽象方法
    3. 接口中的方法都是抽象方法, 不能用abstract去人肉定义
    4. 接口不能被实例化, 需要一个类去实现它
    5. 一个类不能继承多个类  一个类可以实现多个接口

    interface 接口名称 {
        const $NAME = '小王';   // 常量成员(使用 const 关键字定义)
        public function study();    // 抽象方法(不需要使用 abstract 关键字), 
    }

    // 实现接口
    class Student implements 接口名称 {
        const data = 3.14;
        public function study(){
            echo "study";
        };
        public function test() {
            echo self::data;
        }
    }

    $wx = new Student();
    echo $wx::NAME; 
    ```
    * 使用格式: `class 类名 implements 接口名1,接口名2 {......}`
10. `抽象类和接口概念的区别`: 当你关注一个`事物的本质`的时候, 用`抽象类`。当你关注`一个操作`的时候, 用`接口`。
    * 接口是`对动作`的抽象, 表示这个对象能做什么, 对类的局部行为进行抽象。
    * 抽象类是`对根源`的抽象, 表示这个类是什么, 对类的`整体进行抽象`, 对一类事物的抽象描述。
    * 例如: 类(人, 动物)。接口(吃饭, 走路)。
11. `抽象类和接口本质的区别`: 
    * `接口`是`抽象类的变体`, 接口中的所以方法都是抽象的。而`抽象类是声明方法的`, 存在而不去实现它的类。
    * 接口可以实现多继承, 抽象类不行。
    * 接口定义方法, 不能实现。而抽象类可以实现部分方法。
    * 接口中基本数据类型为static, 而抽象类不是。
    * 接口中不能含有静态代码块以及静态方法, 而抽象类可以含有静态方法和静态代码块。

## PHP 常见的关键字
1. `final 关键字`:  只能修饰类和方法。不能使用final关键字来修饰成员属性。
    * 特性: 
        * 使用 final 关键字标识的类不能被继承。
        * 使用 final 关键字标识的方法不能被子类覆盖(重写), 是最终版本。
    * 目的:
        * 一是为了安全
        * 两个没必要继承或重写
2. `static 关键字`: 表示静态的意思, 用于修饰类的成员属性和成员方法。(即静态属性和静态方法)
    * 类中的静态属性和方法不用实例化(new) 就可以直接使用类名访问。
        * 格式: `类::$静态属性`   `类::静态方法`
    * 在类的方法中, 不能用 this 来引用`静态变量`或`静态方法`。而需要使用 self 来引用。
        * 格式: `self::静态属性` `self::静态方法`
    * 静态方法中不可以使用非静态内容。 也就是说不让使用$this。
    * 静态属性是共享的。也就是new很多对象也是共用一个属性。
3. `单例设计模式`: 单例模式主要作用是保证在面向对象编程设计中, `一个类只能有一个实例对象存在`。
4. `const 常量`: const 是在一个类中定义常量的关键字, 在PHP中定义常量使用的是"define()"这个函数, 但是在类里面定义常量使用的是"const"这个关键字。
    * 语法: 
        * const ANT = "constant value";     // 关键字
        * echo self::ANT;   // 类内部访问
        * echo className::ANT;      // 类外部访问
5. `instanceof 关键字`: 用于检测当前对象实例是否属于某一个类或者这个类的子类。
6. `自动加载类`: 当 new 实例化一个不存在的类时, 则自动调用函数`__autoload()`, 并`将类名作为参数传入此函数`。可以使用这个实现类的自动加载。
7. `class_exists`: 检查类是否定义。
8. `get_class_methods`: 返回由类的方法名组成的数组。
9. `get_class`: 返回对象的类名。
10. `get_object_vars`: 返回由对象属性组成的关联数组。
11. `get_parent_class`: 返回对象或类的父类名。
12. `is_a`: 如果对象属于该类或该类是此对象的父类, 则返回TRUE。
13. `method_exists`: 检测类的方法是否存在。
14. `property_exists`: 检测对象或类是否具有该属性。

## PHP 异常处理
```
try {
    if($_GET['num'] == 5){
        throw new Exception('这是一个系统异常');
    }
} catch(Exception $e) {
    echo "错误文件为".$e->getFAILE();
}
```

## PHP 特点说明
1. `__`开始的方法名的方法(PHP给我们提供的), 都是在某一时刻不同情况下自动调用执行的方法。
2. `__toString` 
3. `clone`
4. `namespace`: 命名空间




















