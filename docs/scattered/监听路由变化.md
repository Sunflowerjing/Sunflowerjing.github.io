# 监听路由变化

## 单页面应用, 监听路由变化
* 单页面应用原理, 有两种: `url的hash变化` 或者 `H5的 history`的变化。实现无刷新页面重新渲染。

## 通过`hash来实现单页路由`
1. `改变 url 的 hash 值`是`不会刷新页面`的
2. 早期的前端路由，是通过 hash 来实现无刷新效果。
3. hash 属于 location 对象中，在当前页面中，可以通过: `window.lacation.hash='edit'`;来实现改变当前 url 的 hash 值。
    ```javascript
    赋值前：http://localhost:3000
    赋值后：http://localhost:3000/#edit
    ```
4. 在url中多了以`#结尾的hash值`，但是赋值前后`虽然页面的hash值改变`导致页面完整的url发生了改变，但是`页面是不会刷新的`。
5. 除了可以通过`window.location.hash`来改变当前页面的hash值外，还可以通过html的a标签来实现：
    ```javascript
    <a href="#edit">edit</a>
    ```

## 通过`history实现前端路由`
1. HTML5的`History接口`，History对象是一个底层接口，不继承于任何的接口。
2. History的属性：
    * `History.length`: 返回在会话历史中有多少条记录，包含了当前会话页面。此外如果打开一个新的Tab，那么这个length的值为1.
    * `History.state`:保存了会出发popState事件的方法，所传递过来的属性对象（后面会在pushState和replaceState方法中详细的介绍）
    * `History.back()`: 返回浏览器会话历史中的上一页，跟浏览器的回退按钮功能相同
    * `History.forward()`: 指向浏览器会话历史中的下一页，跟浏览器的前进按钮相同
    * `History.go()`: 可以跳转到浏览器会话历史中的指定的某一个记录页
    * `History.pushState()`: pushState可以将给定的数据压入到浏览器会话历史栈中，该方法接收3个参数，对象，title和一串url。pushState后会改变当前页面url，但是不会伴随着刷新
    * `History.replaceState()`: replaceState将当前的会话页面的url替换成指定的数据，replaceState后也会改变当前页面的url，但是也不会刷新页面。
        * pushState和repalce的相同点：`就是都会改变当前页面显示的url，但都不会刷新页面`。
        * pushState和repalce的不同点：`pushState是压入浏览器的会话历史栈中，会使得History.length加1，而replaceState是替换当前的这条会话历史，因此不会增加History.length.`


## 监听 url 中的 hash 变化
1. 通过`hash改变了url`，会触发`hashchange事件`，只要`监听hashchange事件`，就能捕获到通过hash改变url的行为。
```javascript
window.onhashchange=function(event){
  console.log(event);
}
//或者
window.addEventListener('hashchange',function(event){
   console.log(event);
})
```
2. 当`hash值改变时`，输出一个HashChangeEvent。该HashChangeEvent的具体值为：
```javascript 
{isTrusted: true, oldURL: "http://localhost:3000/", newURL:   "http://localhost:3000/#teg", type: "hashchange".....}
```

## 监听 通过 hastory 来改变 url 的事件
1. History改变url有以下几种方法：
    * History.back()
    * History.forward()
    * History.go()
    * History.pushState()
    * History.replaceState()
2. 注意点:
    * `History.back()、History.forward()、History.go()`事件是`会触发popstate事件`
    ```javascript 
    window.addEventListener('popstate', function(event) {
        console.log(event);
    })

    // 手动调用go/back/forward, 触发popstare事件
    window.history.go();
    window.history.back();
    window.history.forward();

    // 在浏览器中点击后退和前进按钮也会触发popstate事件，这个事件内容为：
    PopStateEvent {isTrusted: true, state: null, type: "popstate", target: Window, currentTarget: Window, …}
    ```
    * `History.pushState()和History.replaceState()`不会触发popstate事件。

## `replaceState` 和 `pushState` 行为的监听
1. 在方法中创建一个新的全局事件
```javascript
const patchUrlStateAction = function(type) {
   var orig = history[type];
   return function() {
       var rv = orig.apply(this, arguments);
      var e = new Event(type);
       e.arguments = arguments;
       window.dispatchEvent(e);
       return rv;
   };
};

history.pushState = patchUrlStateAction('pushState');
history.replaceState = patchUrlStateAction('replaceState');
```
2. 这样就创建了2个全新的事件，事件名为`pushState和replaceState`，这样就可以`监听到pushState和replaceState行为`。
```javascript
window.addEventListener('replaceState', function(e) {
  console.log('THEY DID IT AGAIN! replaceState 111111');
});

window.addEventListener('pushState', function(e) {
  console.log('THEY DID IT AGAIN! pushState 2222222');
});
```




