# 背水一战

1. 防抖: 忘记了apply.....
2. 节流: settimeout 里面清空 time
3. promise: then 里面判断 pending
4. promise.all: 注意 let, fn[i].then
5. apply: context.fn = this
6. call: var args = [...arguments].slice(1);
7. new: [].slice.call(arguments),  Constructor.apply(obj, arguments);
8. 原型链继承
9. http 缓存策略  *
10. 了解 react diff
11. flex 如果一个元素被压缩的话 哪个属性可以不让它压缩



### 待定
1. let 和 var 循环 区别

桥
2. 
3. react 合成事件原理
4. webpack module chunk bundle 之间的关系
5. 如何实现一个 ＄message 组件
6. 手写jsonp
7. rem 适配原理
8. 事件循环
9. 实现继承和原型继承
10. https://github.com/CavsZhouyou/Front-End-Interview-Notebook
11. instaceof 原理
```js
https://www.jianshu.com/p/6c99d3678283

function instance_of(L, R) { //L即stu ；  R即Student

    var O = R.prototype;  //O为Student.prototype,现在指向了per
    L = L.__proto__;    //L为stu._proto_，也随着prototype的改变而指向了per
 
    while (true) {    //执行循环
          if (L === null)  //不通过
              return false;   
          if (O === L)    //判断： Student.prototype ===stu._proto_？
              return true;  //此时，两方都指Person的实例对象per，所以true
          L = L.__proto__;                   
    }
 
} 
```

xu
基础

2. 词法作用域: this
3. 原型链 
4. this 指向
6. 页面优化(服务端渲染、js、css、首屏时间、浏览器 performance 使用、延迟加载) *
7. nginx 负载均衡原理
8. webpack 钩子、pligin *
9. 对函数式编程的理解
10. CSS 盒模型
11. 拖动的原理
12. event loop *

react
13. diff 算法、fiber 与虚拟 DOM
14. state 更新流程 *
15. 数据不可变
16. 与其他框架对比
17. 类组件与函数组件 *
18. 受控组件 与 非受控组件
19. 逻辑组件 与展示组件 *
20. hooks 优点 适用场景 *
21. 事务

算法
22. 实现 promise.all
23. 实现对象深层遍历(两种方式)
24. 实现 bind
25. 防抖
27. 实现 iterator
28. 接口失败后循环调用5次
29. 实现 new
30. 数组展平（参数为自然数，0为全展开，1为展开一层数组，递归与循环实现
31. 实现 footer 的功能（页面不足一屏底部，超过一屏在正文下方
32. 实现 promise
33. 实现进制转换
34. 二叉树求深度