# 面经


## 伴鱼
1. `px` 、`rem`  和 `em` 
    * px: px是相对长度单位，它是相对于`显示器屏幕分辨率`而言的
    * em: 是一种相对长度单位，`相对于自身元素的字号大小`，如果没有`设置即参照父容器的字号大小`或`浏览器默认字号大小`。`相对于使用em单位的元素的字体大小`。
    * rem是css3的新标准也是一种相对长度单位，其相对于`HTML根标签`的字号大小。
    * em和rem: 浏览器根据谁来转化成px值
    * vw(view-width), vh(view-height) 这两个单位是CSS新增的单位，表示视区宽度/高度

2. 适配 小程序
    * `<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">`
    * viewport ：用户网页的可视区域.
    * width：控制viewport的大小，可以指定一个值，如600，或者特殊的值，如device-width为设备的宽度（单位为缩放100%时的CSS的像素）。
    * height：和 width 相对应，指定高度。
    * initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。
    * maximum-scale：允许用户缩放到的最大比例。
    * user-scalable：用户是否可以手动缩放。

    * 方案: https://www.mdaima.com/news/105.html
        * 第一种方法：viewport适配
        * 第二种方法：借助media(媒体查询)实现rem适配  ***
        * 第三种方法：JS配合修改配合rem适配
        * 第四种方法：JS动态修改配合CSS预处理器（less）
        * 第五种方法：JS动态修改配合rem适配
        * 第六种方法：手机淘宝 flexible.js  ***
        * 第七种方法： ***
            * vw:viewport width(可视窗口宽度) 
            * vh:viewport height(可视窗口高度)

3. 数据类型: https://blog.csdn.net/u013592575/article/details/95087953
    * JS 的数据类型有几种？
        * 8种。Number、String、Boolean、Null、undefined、object、symbol、bigInt。
        * Symbol 类型的对象永远不相等，可以用解决属性名冲突的问题
        * bigInt可以安全存储和操作大整数
    * Object 中包含了哪几种类型？
        * 其中包含了Data、function、Array等。这三种是常规用的
    * JS的基本类型和引用类型有哪些呢？
        * 基本类型: String、Number、boolean、null、undefined。
        * 引用类型: object。里面包含的 function、Array、Date。
        * typeof NaN => number。注意: NaN 是 Number 中的一种，非Number 。
        * 用 isNaN（） 检测是否是非数值型。
    * null 和 undefined 有什么区别？
        * Null 只有一个值，是 null。不存在的对象
        * Undefined 只有一个值，是undefined。没有初始化。undefined 是从 null 中派生出来的。
        * 简单理解就是：undefined 是没有定义的，null 是定义了但是为空。

4. typeof  和 instanof
    * typeof适用于基础数据类型判断，引用类型判断都是object
    * a instanceof b：判断a是否为b的实例，可以用于继承关系中
    * instanceof 只能处理两个对象是否属于的实例关系
    * instanof工作原理：判断实例对象的__proto__属性和构造函数的prototype是否同一个地址，只要在原型链上的构造函数，都会被instanceof认为是实例的构造函数。如图：





5. 缓存 http 强缓存和协商缓存

6. 客户端，缓存信息有哪些？

7. 原型链的场景
    * 原型链主要用于继承，其实就是为了代码复用

8. await 后面可以和常量吗

10. new 操作符做了什么
    ```js
    // new运算符及背后工作原理 new后跟构造函数
    // 1，一个新对象被创建，它继承自func.prototype（构造函数的原型对象）
    // 2，构造函数func被执行，执行的时候，相应的传参会被传入，同时上下文（this）会被指定为这个新实例
    // 3，如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果，如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象
    var new2 = function(func) {
        var o = Object.create(func.prototype);
        var k = func.call(o);
        if (typeof k === 'object' && k != null) {
            return k;
        } else {
            return o;
        }
    };
    ```

11. bind 的 this
    * bind方法会创建一个新函数 称为绑定函数
    * bind方法的返回值是函数


12. 请写出下面代码的输出内容
```javascript
console.log(1);
setTimeout(() => {
  console.log(2);
  Promise.resolve().then(data => {
    console.log(3);
  });
});
new Promise((resolve) => {
  resolve()
  console.log(4)
}).then(() => {
  console.log(5);
  setTimeout(() => {
    console.log(6);
  });
}).then(() => console.log(7))
console.log(8); 
```

13. 请写出下面代码的输出内容
```js
console.log(fish1,fish2,fish3); 
var fish1 = function(){
  console.log('welcome to Palfish-1')
}
var fish1,fish2,fish3;
function fish2(){
  console.log('welcome to Palfish-2')
}
var fish3 = 'welcome to Palfish-3'
var fish1,fish2,fish3;
console.log(fish1,fish2,fish3);
```


14. 请写出下面代码的输出内容
```js
var nickname = "LiLei";
function Person(name){
  this.nickname = name;
  this.sayHi = function() {
    console.log(this.nickname);
    setTimeout(function(){
      console.log(this.nickname);
    }, 1000);
  }
}
var Male = {
  nickname: 'xiaofang',
  sayHi: () => {
    console.log(this.nickname);
  }
}
var person = new（Person.bind(Male, 'XiaoHong'));   
person.sayHi(); // ==> 输出
```



15. 请写出下面代码的输出内容
```js
let object = {a:0};
function fun(obj) {
    obj.a=1;
    obj={a:2};
    obj.b=2;
}
fun(object);
console.log(object);  // ==> 输出：
```
// {a:1}




16. 实现一个LazyMan，可以按照以下方式调用:
```js
LazyMan(“Hank”)输出:
Hi! This is Hank!

LazyMan(“Hank”).sleep(10).eat(“dinner”)输出
Hi! This is Hank!
//等待10秒..
Wake up after 10
Eat dinner~

LazyMan(“Hank”).eat(“dinner”).eat(“supper”)输出
Hi This is Hank!
Eat dinner~
Eat supper~

以此类推。
```


17. 找出二叉树中某两个节点的第一个共同祖先，不得将其他的节点存储在另外的数据结构中。

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]，相应的树型结构为：

```js
    3
   / \
  5   1
 / \ / \
6  2 0  8
  / \
 7   4


```
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。


## 好未来

1. 去掉一个数组中的重复项，并按升序排序
let param= [3,6,7,8,7,4,5,3]      
函数（param）  //[3,4,5,6,7,8]
```js
    es6提供了新的数据结构Set, 去重
    Array.from(去重结果)
    sort 排序
```


2. let parmas = '21349803458468485’
http://www.ccued.com/post/37.html


3. 判断数组中是否满足有其中一项等于其它两项之和；
var arr = [0, 3, 6, 4,7,5,6,2,3,56,4];

4. 快排算法
```js
/**
 * 快速排序
 * @param nums  数组
 * @param left  排序的左边界索引
 * @param right 排序的右边界索引
 * 
 * 思路: https://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/
 * 
 * 振凯: https://wii.pub/2021/04/12/coding/algorithm/sort/
 */
function qsort(nums, left, right) {
    if (left >= right) return;

    var pivot = nums[left], i = left, j = right;
    while (i < j) {
        while (i < j && nums[j] > pivot) --j;
        nums[i] = nums[j];

        while (i < j && nums[i] <= pivot) ++i;
        nums[j] = nums[i];
    }
    nums[i] = pivot;
    qsort(nums, left, i-1);
    qsort(nums, i+1, right);
}

var v;
v = [3, 2, 1, 3, 4, 0, -1, 8, 9, 1, 0];
qsort(v, 0, v.length - 1);
console.log(v);

v = [];
qsort(v, 0, v.length - 1);
console.log(v);

v = [5, 4, 3, 2, 1];
qsort(v, 0, v.length - 1);
console.log(v);
```




5. 二叉树广度遍历深度遍历
```js
/**
 * 定义二叉树节点
 */
function TreeNode(val) {
    this.val = val;
    this.left = this.right = null;
}

// 深度优先遍历
function dfs(root) {
    if (root == null) return;

    process.stdout.write(root.val + ' ');
    dfs(root.left);
    dfs(root.right);
}

// 广度优先遍历
function bfs(root) {
    var nodes = [root];
    while (nodes.length != 0) {
        var cur = nodes.shift()
        process.stdout.write(cur.val + ' ');
        if (cur.left != null) nodes.push(cur.left);
        if (cur.right != null) nodes.push(cur.right);
    }
}

// 构造树
function buildTree(nums, idx) {
    var v = nums.shift();
    if (v == null || v == undefined) return null;

    var node = new TreeNode(v);
    node.left = buildTree(nums);
    node.right = buildTree(nums);
    return node;
}

var t = [1, 2, 4, 6, null, null, null, 5, 7, 8, null, null, 9, null, null, null, 3, null, null];
var tree = buildTree(t);
dfs(tree);
console.log();
bfs(tree);
console.log();
```


6. 深拷贝
    * 浅拷贝： 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用
    * 深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，`是“值”而不是“引用”`
    * 为什么要使用深拷贝？
        * 我们希望在改变新的数组（对象）的时候，不改变原数组（对象）
    * 怎么检验深拷贝成功: 改变任意一个新对象/数组中的属性/元素, 都不改变原对象/数组





## 快手
1. 准备准备 TypeScript 基础、入门、进阶

2. 算法，什么分解质因数之类的


3. React Mobx 原理性、性能优化、最佳实践、痛点之类

4. 项目的亮点也总结包装一下




















