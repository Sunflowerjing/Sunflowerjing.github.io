# 面经


1. 自我介绍
    * 您好，很荣幸参加此次面试。我叫耿静静，内蒙古呼伦贝尔人。今天想面试贵公司的前端岗位。2018年7月加入 Qunar， 在 Qunar 工作2年多，目前在基础研发部，担任前端工程师这一职责。在此期间接触过小程序, 开发过埋点SDK，以及用 react、redux和 mobx 等开发前端项目。
    

2. 娜娜奇小程序主包瘦身
  * 项目背景: 由于微信小程序主包 size 过大，即将超过2M, 已经到了2M 的临界值。导致一些必要的需求不能在主包中添加。 所以需要对主包的 size 进行优化。
  * 实施方案: 2种结合
    * 第一种：常见的小程序瘦身方案: 首先剔除无用文件、图片用于CDN等(效果不理想)
    * 第二种：拆包形式。除了 tab 页，其余的页面都以分包的形式提取出去。
      * 但有个问题，就是页面的 URL 改变了，其他业务线引用的地址变化了, 导致拆包前的页面找不到。为了让业务线无感知, 不想业务线手动修改。
      * 解决方案是: 定义 map 文件，让原始 URL 和 新的 URL 做一个映射。
      然后用Object.defineProperty劫持原生底层路由: reLaunch、rediectTo、navigateTo。(这个方案只支持小程序这样做)
      由于快应用的机制，不允许对快应用中路由进行劫持，所以快应用中，则对React.api[navigateTo || redirectTo], 进行重写
      以上方案是：端内跳转。端外跳转是不会走reLaunch、rediectTo、navigateTo这些API，所以需要在 onPageNotFound 中进行处理。直接判断跳转路径是否在我们的 map 文件中，在的话我们就跳转。


3. 去哪儿埋点 SDK
  * 项目背景: 为 Qunar各业务线，提供 小程序 和 h5 埋点 SDK。 目的是: 统计用户数据，分析用户行为等。
  * 实施方案: 手动埋点 和 自动埋点
    * 手动埋点
    * 自动埋点: 
      * 通过 addEventListener 监听 `DOMContentLoaded` 事件。 也就是初始的 html 文档被完全加载和解析完成后, 触发此事件。 
      * 通过 addEventListener 监听 `popstate`事件。但 popstate 不会触发`pushState/replaceState`事件, 所以需要重写history.pushState 和 history.replaceState 这两个事件，也就是在方法中创建一个新的全局事件。
      ```js
      const patchUrlStateAction = (type) => {
        const orig = history[type];
          return function() {
              const rv = orig.apply(this, arguments);
              const e = new Event(type);
              e.arguments = arguments;
              getGlobal().dispatchEvent(e);
              return rv;
          };
      };
      ```
  * 发送方式: 立即发送和批量发送
    * 立即发送: 业务线手动调用时候传的参数，第二个为 true 时，则为立即发送
    * 批量发送: 根据节流机制设计的，在设置的时间范围内, 最后一次执行
        还有一种情况，如果日志队列数量大于等于阈值，则立马发送
  * 遇到的问题 
    *  A -> B 页面, 因为延迟发送请求 A 页面数据丢失
  * 怎么保证发送成功
    * 回调
    * 缓存
    * 信标




4. mportal 平台
  * 项目背景: 主要是客户端打包、发布、运营工具平台, 例如: 客户端的预计发版时间要提前创建出来，提供此次发版组件名称和版本号等。如不想手动填写，平台会给你默认创建与线上的版本号对应。每个组件对应的 case 地址都在平台中添加。同时也会展示客户端对应的组件列表, 以及当前的状态。
  * BFF 层: 前端需要什么样的接口就让服务器端提供, 同时在客户端使用这样的逻辑会占用更多的浏览器资源。，前端将有更少的逻辑，BFF 有助于简化数据展示，并为前端提供一个目的明确的接口。
    * 调用相关的微服务 API 并获取所需数据
    * 根据前端展现来处理数据
    * 将格式化后的数据发送到前端
    * 插件
    * 中间件
    * 路由
    * 渲染
  * CI: 持续集成(持续集成指的是，频繁地（一天多次）将代码集成到主干。)
  * CD: 
    * 持续交付: 指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。`Jenkins`
    * 持续部署: 指的是代码通过评审以后，自动部署到生产环境。
  * const ws = new WebSocket('ws://localhost:8080');
    * ws.onopen  ws.onmessage  ws.onclose ws.onerror


## 伴鱼
1. `px` 、`rem`  和 `em` 
    * px: px是相对长度单位，它是相对于`显示器屏幕分辨率`而言的
    * em: 是一种相对长度单位，`相对于自身元素的字号大小`，如果没有`设置即参照父容器的字号大小`或`浏览器默认字号大小`。`相对于使用em单位的元素的字体大小`。
    * rem是css3的新标准也是一种相对长度单位，其相对于`HTML根标签`的字号大小。
    * em和rem: 浏览器根据谁来转化成px值
    * vw(view-width), vh(view-height) 这两个单位是CSS新增的单位，表示视区宽度/高度

2. 适配 小程序
    * `<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">`
    * viewport ：用户网页的可视区域.
    * width：控制viewport的大小，可以指定一个值，如600，或者特殊的值，如device-width为设备的宽度（单位为缩放100%时的CSS的像素）。
    * height：和 width 相对应，指定高度。
    * initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。
    * maximum-scale：允许用户缩放到的最大比例。
    * user-scalable：用户是否可以手动缩放。

    * 方案: https://www.mdaima.com/news/105.html
        * 第一种方法：viewport适配
        * 第二种方法：借助media(媒体查询)实现rem适配  ***
        * 第三种方法：JS配合修改配合rem适配
        * 第四种方法：JS动态修改配合CSS预处理器（less）
        * 第五种方法：JS动态修改配合rem适配
        * 第六种方法：手机淘宝 flexible.js  ***
        * 第七种方法： ***
            * vw:viewport width(可视窗口宽度) 
            * vh:viewport height(可视窗口高度)

3. 数据类型: https://blog.csdn.net/u013592575/article/details/95087953
    * JS 的数据类型有几种？
        * 8种。Number、String、Boolean、Null、undefined、object、symbol、bigInt。
        * Symbol 类型的对象永远不相等，可以用解决属性名冲突的问题
        * bigInt可以安全存储和操作大整数
    * Object 中包含了哪几种类型？
        * 其中包含了Data、function、Array等。这三种是常规用的
    * JS的基本类型和引用类型有哪些呢？
        * 基本类型: String、Number、boolean、null、undefined。
        * 引用类型: object。里面包含的 function、Array、Date。
        * typeof NaN => number。注意: NaN 是 Number 中的一种，非Number 。
        * 用 isNaN（） 检测是否是非数值型。
    * null 和 undefined 有什么区别？
        * Null 只有一个值，是 null。不存在的对象
        * Undefined 只有一个值，是undefined。没有初始化。undefined 是从 null 中派生出来的。
        * 简单理解就是：undefined 是没有定义的，null 是定义了但是为空。

4. typeof  和 instanof
    * typeof适用于基础数据类型判断，引用类型判断都是object
    * a instanceof b：判断a是否为b的实例，可以用于继承关系中
    * instanceof 只能处理两个对象是否属于的实例关系
    * instanof工作原理：判断实例对象的__proto__属性和构造函数的prototype是否同一个地址，只要在原型链上的构造函数，都会被instanceof认为是实例的构造函数。如图：





5. 缓存 http 强缓存和协商缓存

6. 客户端，缓存信息有哪些？

7. 原型链的场景
    * 原型链主要用于继承，其实就是为了代码复用

8. await 后面可以和常量吗

10. new 操作符做了什么
    ```js
    // new运算符及背后工作原理 new后跟构造函数
    // 1，一个新对象被创建，它继承自func.prototype（构造函数的原型对象）
    // 2，构造函数func被执行，执行的时候，相应的传参会被传入，同时上下文（this）会被指定为这个新实例
    // 3，如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果，如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象
    var new2 = function(func) {
        var o = Object.create(func.prototype);
        var k = func.call(o);
        if (typeof k === 'object' && k != null) {
            return k;
        } else {
            return o;
        }
    };
    ```

11. bind 的 this
    * bind方法会创建一个新函数 称为绑定函数
    * bind方法的返回值是函数


12. 请写出下面代码的输出内容
```javascript
console.log(1);
setTimeout(() => {
  console.log(2);
  Promise.resolve().then(data => {
    console.log(3);
  });
});
new Promise((resolve) => {
  resolve()
  console.log(4)
}).then(() => {
  console.log(5);
  setTimeout(() => {
    console.log(6);
  });
}).then(() => console.log(7))
console.log(8); 
```

13. 请写出下面代码的输出内容
```js
console.log(fish1,fish2,fish3); 
var fish1 = function(){
  console.log('welcome to Palfish-1')
}
var fish1,fish2,fish3;
function fish2(){
  console.log('welcome to Palfish-2')
}
var fish3 = 'welcome to Palfish-3'
var fish1,fish2,fish3;
console.log(fish1,fish2,fish3);
```


14. 请写出下面代码的输出内容
```js
var nickname = "LiLei";
function Person(name){
  this.nickname = name;
  this.sayHi = function() {
    console.log(this.nickname);
    setTimeout(function(){
      console.log(this.nickname);
    }, 1000);
  }
}
var Male = {
  nickname: 'xiaofang',
  sayHi: () => {
    console.log(this.nickname);
  }
}
var person = new（Person.bind(Male, 'XiaoHong'));   
person.sayHi(); // ==> 输出
```



15. 请写出下面代码的输出内容
```js
let object = {a:0};
function fun(obj) {
    obj.a=1;
    obj={a:2};
    obj.b=2;
}
fun(object);
console.log(object);  // ==> 输出：
```
// {a:1}




16. 实现一个LazyMan，可以按照以下方式调用:
```js
LazyMan(“Hank”)输出:
Hi! This is Hank!

LazyMan(“Hank”).sleep(10).eat(“dinner”)输出
Hi! This is Hank!
//等待10秒..
Wake up after 10
Eat dinner~

LazyMan(“Hank”).eat(“dinner”).eat(“supper”)输出
Hi This is Hank!
Eat dinner~
Eat supper~

以此类推。
```


17. 找出二叉树中某两个节点的第一个共同祖先，不得将其他的节点存储在另外的数据结构中。

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]，相应的树型结构为：

```js
    3
   / \
  5   1
 / \ / \
6  2 0  8
  / \
 7   4


```
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。


18. React在body下追加全局组件
  * popupMaskNode

19. 设计蒙层组件, 需要哪些接口

20. 监听点击事件, 页面点击用户行为

21. Xpath
  ```js
  //封装xpath
  function getElementByXpath(xpath){
      var element = document.evaluate(xpath,document).iterateNext();
      return element;
  }
  ```

## 好未来

1. 去掉一个数组中的重复项，并按升序排序
let param= [3,6,7,8,7,4,5,3]      
函数（param）  //[3,4,5,6,7,8]
```js
    es6提供了新的数据结构Set, 去重
    Array.from(去重结果)
    sort 排序
```


2. let parmas = '21349803458468485’
http://www.ccued.com/post/37.html


3. 判断数组中是否满足有其中一项等于其它两项之和；
var arr = [0, 3, 6, 4,7,5,6,2,3,56,4];

4. 快排算法
```js
/**
 * 快速排序
 * @param nums  数组
 * @param left  排序的左边界索引
 * @param right 排序的右边界索引
 * 
 * 思路: https://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/
 * 
 * 振凯: https://wii.pub/2021/04/12/coding/algorithm/sort/
 */
function qsort(nums, left, right) {
    if (left >= right) return;

    var pivot = nums[left], i = left, j = right;
    while (i < j) {
        while (i < j && nums[j] > pivot) --j;
        nums[i] = nums[j];

        while (i < j && nums[i] <= pivot) ++i;
        nums[j] = nums[i];
    }
    nums[i] = pivot;
    qsort(nums, left, i-1);
    qsort(nums, i+1, right);
}

var v;
v = [3, 2, 1, 3, 4, 0, -1, 8, 9, 1, 0];
qsort(v, 0, v.length - 1);
console.log(v);

v = [];
qsort(v, 0, v.length - 1);
console.log(v);

v = [5, 4, 3, 2, 1];
qsort(v, 0, v.length - 1);
console.log(v);
```




5. 二叉树广度遍历深度遍历
```js
/**
 * 定义二叉树节点
 */
function TreeNode(val) {
    this.val = val;
    this.left = this.right = null;
}

// 深度优先遍历
function dfs(root) {
    if (root == null) return;

    process.stdout.write(root.val + ' ');
    dfs(root.left);
    dfs(root.right);
}

// 广度优先遍历
function bfs(root) {
    var nodes = [root];
    while (nodes.length != 0) {
        var cur = nodes.shift()
        process.stdout.write(cur.val + ' ');
        if (cur.left != null) nodes.push(cur.left);
        if (cur.right != null) nodes.push(cur.right);
    }
}

// 构造树
function buildTree(nums, idx) {
    var v = nums.shift();
    if (v == null || v == undefined) return null;

    var node = new TreeNode(v);
    node.left = buildTree(nums);
    node.right = buildTree(nums);
    return node;
}

var t = [1, 2, 4, 6, null, null, null, 5, 7, 8, null, null, 9, null, null, null, 3, null, null];
var tree = buildTree(t);
dfs(tree);
console.log();
bfs(tree);
console.log();
```


6. 深拷贝
    * 浅拷贝： 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用
    * 深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，`是“值”而不是“引用”`
    * 为什么要使用深拷贝？
        * 我们希望在改变新的数组（对象）的时候，不改变原数组（对象）
    * 怎么检验深拷贝成功: 改变任意一个新对象/数组中的属性/元素, 都不改变原对象/数组





## 快手
1. 准备准备 TypeScript 基础、入门、进阶

2. 算法，什么分解质因数之类的

3. React Mobx 原理性、性能优化、最佳实践、痛点之类

4. 项目的亮点也总结包装一下



## 跟谁学
1. sdk
  * 信标: Beacon. 信标（Beacon）可以异步与非阻塞的数据传输，从而最大限度地减少与其他关键操作的资源争用，同时它可以确保这些请求一定会被处理并将其传递到服务端：
    * 信标请求优先避免与关键操作和更高优先级的网络请求竞争。
    * 信标请求可以有效地合并，以优化移动设备上的能量使用。
    * 保证页面卸载之前启动信标请求，并允许运行完成且不会阻塞请求或阻塞处理用户交互事件的任务
    * window.navigator.sendBeacon('/apiLog', data)

2. 小程序瘦身-收益

3. h5 性能优化
  * 首屏加载
    * 首次绘制（First Paint，FP）
    * 首次内容绘制（First Contentful Paint，FCP）
    * 白屏时间: 从路由改变起(即用户再按下回车的瞬间)到首次内容绘制(即能看到第一个内容)为止算白屏时间 => `白屏时间 = firstPaint - performance.timing.navigationStart`
    * 白屏时间内发生了什么:
      * 回车按下,浏览器解析网址,进行 DNS 查询,查询返回 IP,通过 IP 发出 HTTP(S) 请求
      * 服务器返回HTML,浏览器开始解析 HTML,此时触发请求 js 和 css 资源
      * js 被加载,开始执行 js,调用各种函数创建 DOM 并渲染到根节点,直到第一个可见元素产生
    * 有一款webpack 插件叫 html-webpack-plugin 
      * 在其中配置 html 就可以在文件中插入 loading 图。
    * (伪)服务端渲染
      * prerender-spa-plugin 
    * 开启 HTTP2
    * 开启浏览器缓存
      * 响应头
        * Expires: 响应头，代表该资源的过期时间。
        * Cache-Control: 请求/响应头，缓存控制字段，精确控制缓存策略。
        * Last-Modified: 响应头，资源最近修改时间，由服务器告诉浏览器。
        * Etag: 响应头，资源标识，由服务器告诉浏览器。
      * 请求头
        * If-Modified-Since: 请求头，资源最近修改时间，由浏览器告诉服务器。
        * If-None-Match: 请求头，缓存资源标识，由浏览器告诉服务器。
      * 配对使用的字段：
        * If-Modified-Since 和 Last-Modified
        * Etag 和 If-None-Match
      * https://segmentfault.com/a/1190000020690092


4. react-sogo

5. 去除字符串中重复出现的数字对于给定的由数字1-n（10 < n < 100）构成的字符串，数字之间以空格隔开，无序，实现一个函数，去除字符串中出现的重复数字，且输出顺序和输入保持相对一致。
```js
function arr(str){
  var arr = []
  for(var i=0; i<str.length; i++){
      if(str.indexOf(str[i]) === str.lastIndexOf(str[i])){
          arr.push(str[i])
      }
  }
  return arr.join('')
}
arr('1 1 2 1 3 5 4 6 3 7')
```



















## 神策
1. 娜娜奇 编译 实现

2. 项目从 git 到 上线的整体流程是什么? 发布

2. eventlop

3. pm2 使用
  * pm2 start app.js # 启动app.js应用程序
  * pm2 list # 列表 PM2 启动的所有的`应用程序`
  * pm2 logs # 显示所有应用程序的日志
  * pm2 logs [app-name] # 显示指定应用程序的日志
  * pm2 stop all # 停止所有的应用程序
  * PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单


4. PureComponent 和  Component

5. 写一下 object.assign 的 polyfill

6. 回朔 重流

7. 盒模型: Margin+Border+Padding+Content
  * 标准模型: content = content
  * IE模型(怪异模式): content = content + border + padding
  * 切换标准模型和IE模型: `box-sizing:border-box || content-box || inherit`
    * 当使用`content-box`时：页面将采用`标准模式来解析计算`，content-box也是默认模式  
    * 当使用`border-box`时，页面将采用`怪异模式解析计算`，怪异模式也称为IE模式
    * 当使用`inherit`时：页面将从父元素继承box-sizing的值


## 猿辅导
1. css 样式
    ```js
    【【 abcd              】【1234】】
    【【 abcdefg.....】【123456】】
    ```
2. event loop
    ```js
    setTimeout(() => console.log(1))
    new Promise(resolve => {
        resolve()
        console.log(2)
    }).then(() => {
        setTimeout(() => console.log(3))
        console.log(4)
        Promise.resolve().then(() => {
            console.log(5)
        }).then(() => {
            Promise.resolve().then(() => {
                console.log(6)
            })
        })
        console.log(8)
    })
    console.log(7)

    27485613
    ```

3. 实现 new 

4. 节流, 防抖

5. 实现 Promise.all()



